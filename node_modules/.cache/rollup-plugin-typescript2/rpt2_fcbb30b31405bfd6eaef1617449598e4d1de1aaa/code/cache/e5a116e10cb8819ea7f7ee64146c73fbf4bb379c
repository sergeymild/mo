{"code":"import { CaughtException, IDerivationState_, TraceMode, autorun, clearObserving, comparer, createAction, createInstanceofPredicate, endBatch, getNextId, globalState, isCaughtException, isSpyEnabled, propagateChangeConfirmed, propagateMaybeChanged, reportObserved, shouldCompute, spyReport, startBatch, toPrimitive, trackDerivedFunction, untrackedEnd, untrackedStart, UPDATE, die, allowStateChangesStart, allowStateChangesEnd } from \"../internal\";\r\n/**\r\n * A node in the state dependency root that observes other nodes, and can be observed itself.\r\n *\r\n * ComputedValue will remember the result of the computation for the duration of the batch, or\r\n * while being observed.\r\n *\r\n * During this time it will recompute only when one of its direct dependencies changed,\r\n * but only when it is being accessed with `ComputedValue.get()`.\r\n *\r\n * Implementation description:\r\n * 1. First time it's being accessed it will compute and remember result\r\n *    give back remembered result until 2. happens\r\n * 2. First time any deep dependency change, propagate POSSIBLY_STALE to all observers, wait for 3.\r\n * 3. When it's being accessed, recompute if any shallow dependency changed.\r\n *    if result changed: propagate STALE to all observers, that were POSSIBLY_STALE from the last step.\r\n *    go to step 2. either way\r\n *\r\n * If at any point it's outside batch and it isn't observed: reset everything and go to 1.\r\n */\r\nexport class ComputedValue {\r\n    dependenciesState_ = IDerivationState_.NOT_TRACKING_;\r\n    observing_ = []; // nodes we are looking at. Our value depends on these nodes\r\n    newObserving_ = null; // during tracking it's an array with new observed observers\r\n    isBeingObserved_ = false;\r\n    isPendingUnobservation_ = false;\r\n    observers_ = new Set();\r\n    diffValue_ = 0;\r\n    runId_ = 0;\r\n    lastAccessedBy_ = 0;\r\n    lowestObserverState_ = IDerivationState_.UP_TO_DATE_;\r\n    unboundDepsCount_ = 0;\r\n    value_ = new CaughtException(null);\r\n    name_;\r\n    triggeredBy_;\r\n    isComputing_ = false; // to check for cycles\r\n    isRunningSetter_ = false;\r\n    derivation; // N.B: unminified as it is used by MST\r\n    setter_;\r\n    isTracing_ = TraceMode.NONE;\r\n    scope_;\r\n    equals_;\r\n    requiresReaction_;\r\n    keepAlive_;\r\n    /**\r\n     * Create a new computed value based on a function expression.\r\n     *\r\n     * The `name` property is for debug purposes only.\r\n     *\r\n     * The `equals` property specifies the comparer function to use to determine if a newly produced\r\n     * value differs from the previous value. Two comparers are provided in the library; `defaultComparer`\r\n     * compares based on identity comparison (===), and `structuralComparer` deeply compares the structure.\r\n     * Structural comparison can be convenient if you always produce a new aggregated object and\r\n     * don't want to notify observers if it is structurally the same.\r\n     * This is useful for working with vectors, mouse coordinates etc.\r\n     */\r\n    constructor(options) {\r\n        if (!options.get)\r\n            die(31);\r\n        this.derivation = options.get;\r\n        this.name_ = options.name || (__DEV__ ? \"ComputedValue@\" + getNextId() : \"ComputedValue\");\r\n        if (options.set) {\r\n            this.setter_ = createAction(__DEV__ ? this.name_ + \"-setter\" : \"ComputedValue-setter\", options.set);\r\n        }\r\n        this.equals_ =\r\n            options.equals ||\r\n                (options.compareStructural || options.struct\r\n                    ? comparer.structural\r\n                    : comparer.default);\r\n        this.scope_ = options.context;\r\n        this.requiresReaction_ = !!options.requiresReaction;\r\n        this.keepAlive_ = !!options.keepAlive;\r\n    }\r\n    onBecomeStale_() {\r\n        propagateMaybeChanged(this);\r\n    }\r\n    onBOL;\r\n    onBUOL;\r\n    onBO() {\r\n        if (this.onBOL) {\r\n            this.onBOL.forEach(listener => listener());\r\n        }\r\n    }\r\n    onBUO() {\r\n        if (this.onBUOL) {\r\n            this.onBUOL.forEach(listener => listener());\r\n        }\r\n    }\r\n    /**\r\n     * Returns the current value of this computed value.\r\n     * Will evaluate its computation first if needed.\r\n     */\r\n    get() {\r\n        if (this.isComputing_)\r\n            die(32, this.name_, this.derivation);\r\n        if (globalState.inBatch === 0 &&\r\n            // !globalState.trackingDerivatpion &&\r\n            this.observers_.size === 0 &&\r\n            !this.keepAlive_) {\r\n            if (shouldCompute(this)) {\r\n                this.warnAboutUntrackedRead_();\r\n                startBatch(); // See perf test 'computed memoization'\r\n                this.value_ = this.computeValue_(false);\r\n                endBatch();\r\n            }\r\n        }\r\n        else {\r\n            reportObserved(this);\r\n            if (shouldCompute(this)) {\r\n                let prevTrackingContext = globalState.trackingContext;\r\n                if (this.keepAlive_ && !prevTrackingContext)\r\n                    globalState.trackingContext = this;\r\n                if (this.trackAndCompute())\r\n                    propagateChangeConfirmed(this);\r\n                globalState.trackingContext = prevTrackingContext;\r\n            }\r\n        }\r\n        const result = this.value_;\r\n        if (isCaughtException(result))\r\n            throw result.cause;\r\n        return result;\r\n    }\r\n    set(value) {\r\n        if (this.setter_) {\r\n            if (this.isRunningSetter_)\r\n                die(33, this.name_);\r\n            this.isRunningSetter_ = true;\r\n            try {\r\n                this.setter_.call(this.scope_, value);\r\n            }\r\n            finally {\r\n                this.isRunningSetter_ = false;\r\n            }\r\n        }\r\n        else\r\n            die(34, this.name_);\r\n    }\r\n    trackAndCompute() {\r\n        // N.B: unminified as it is used by MST\r\n        const oldValue = this.value_;\r\n        const wasSuspended = \r\n        /* see #1208 */ this.dependenciesState_ === IDerivationState_.NOT_TRACKING_;\r\n        const newValue = this.computeValue_(true);\r\n        if (__DEV__ && isSpyEnabled()) {\r\n            spyReport({\r\n                observableKind: \"computed\",\r\n                debugObjectName: this.name_,\r\n                object: this.scope_,\r\n                type: \"update\",\r\n                oldValue: this.value_,\r\n                newValue\r\n            });\r\n        }\r\n        const changed = wasSuspended ||\r\n            isCaughtException(oldValue) ||\r\n            isCaughtException(newValue) ||\r\n            !this.equals_(oldValue, newValue);\r\n        if (changed) {\r\n            this.value_ = newValue;\r\n        }\r\n        return changed;\r\n    }\r\n    computeValue_(track) {\r\n        this.isComputing_ = true;\r\n        // don't allow state changes during computation\r\n        const prev = allowStateChangesStart(false);\r\n        let res;\r\n        if (track) {\r\n            res = trackDerivedFunction(this, this.derivation, this.scope_);\r\n        }\r\n        else {\r\n            if (globalState.disableErrorBoundaries === true) {\r\n                res = this.derivation.call(this.scope_);\r\n            }\r\n            else {\r\n                try {\r\n                    res = this.derivation.call(this.scope_);\r\n                }\r\n                catch (e) {\r\n                    res = new CaughtException(e);\r\n                }\r\n            }\r\n        }\r\n        allowStateChangesEnd(prev);\r\n        this.isComputing_ = false;\r\n        return res;\r\n    }\r\n    suspend_() {\r\n        if (!this.keepAlive_) {\r\n            clearObserving(this);\r\n            this.value_ = undefined; // don't hold on to computed value!\r\n        }\r\n    }\r\n    observe_(listener, fireImmediately) {\r\n        let firstTime = true;\r\n        let prevValue = undefined;\r\n        return autorun(() => {\r\n            // TODO: why is this in a different place than the spyReport() function? in all other observables it's called in the same place\r\n            let newValue = this.get();\r\n            if (!firstTime || fireImmediately) {\r\n                const prevU = untrackedStart();\r\n                listener({\r\n                    observableKind: \"computed\",\r\n                    debugObjectName: this.name_,\r\n                    type: UPDATE,\r\n                    object: this,\r\n                    newValue,\r\n                    oldValue: prevValue\r\n                });\r\n                untrackedEnd(prevU);\r\n            }\r\n            firstTime = false;\r\n            prevValue = newValue;\r\n        });\r\n    }\r\n    warnAboutUntrackedRead_() {\r\n        if (!__DEV__)\r\n            return;\r\n        if (this.requiresReaction_ === true) {\r\n            die(`[mobx] Computed value ${this.name_} is read outside a reactive context`);\r\n        }\r\n        if (this.isTracing_ !== TraceMode.NONE) {\r\n            console.log(`[mobx.trace] '${this.name_}' is being read outside a reactive context. Doing a full recompute`);\r\n        }\r\n        if (globalState.computedRequiresReaction) {\r\n            console.warn(`[mobx] Computed value ${this.name_} is being read outside a reactive context. Doing a full recompute`);\r\n        }\r\n    }\r\n    toString() {\r\n        return `${this.name_}[${this.derivation.toString()}]`;\r\n    }\r\n    valueOf() {\r\n        return toPrimitive(this.get());\r\n    }\r\n    [Symbol.toPrimitive]() {\r\n        return this.valueOf();\r\n    }\r\n}\r\nexport const isComputedValue = createInstanceofPredicate(\"ComputedValue\", ComputedValue);\r\n//# sourceMappingURL=computedvalue.js.map","references":["/Users/sergeigolishnikov/development/web/mobx/packages/mobx/src/internal.ts"],"map":"{\"version\":3,\"file\":\"computedvalue.js\",\"sourceRoot\":\"\",\"sources\":[\"../../../../../src/core/computedvalue.ts\"],\"names\":[],\"mappings\":\"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\"}"}
