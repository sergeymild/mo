{"code":"import { getAnnotationFromOptions, propagateChanged, isAnnotation, $mobx, Atom, ComputedValue, ObservableValue, addHiddenProp, createInstanceofPredicate, endBatch, getNextId, hasInterceptors, hasListeners, interceptChange, isObject, isPlainObject, isSpyEnabled, notifyListeners, referenceEnhancer, registerInterceptor, registerListener, spyReportEnd, spyReportStart, startBatch, stringifyKey, globalState, observable, ADD, UPDATE, die, hasProp, getDescriptor, storedAnnotationsSymbol, ownKeys, isOverride, defineProperty, inferAnnotationFromDescriptor, getDebugName, getAdministration, objectPrototype } from \"../internal\";\r\n// closestPrototypeofTarget[inferredAnnotationsSymbol] = new Map<PropertyKes, Annotation>()\r\nexport const inferredAnnotationsSymbol = Symbol(\"mobx-inferred-annotations\");\r\nconst descriptorCache = Object.create(null);\r\nconst REMOVE = \"remove\";\r\nexport class ObservableObjectAdministration {\r\n    target_;\r\n    values_;\r\n    name_;\r\n    defaultAnnotation_;\r\n    autoBind_;\r\n    keysAtom_;\r\n    changeListeners_;\r\n    interceptors_;\r\n    proxy_;\r\n    isPlainObject_;\r\n    appliedAnnotations_;\r\n    pendingKeys_;\r\n    constructor(target_, values_ = new Map(), name_, \r\n    // Used anytime annotation is not explicitely provided\r\n    defaultAnnotation_ = observable, \r\n    // Bind automatically inferred actions?\r\n    autoBind_ = false) {\r\n        this.target_ = target_;\r\n        this.values_ = values_;\r\n        this.name_ = name_;\r\n        this.defaultAnnotation_ = defaultAnnotation_;\r\n        this.autoBind_ = autoBind_;\r\n        this.keysAtom_ = new Atom(__DEV__ ? `${this.name_}.keys` : \"ObservableObject.keys\");\r\n        // Optimization: we use this frequently\r\n        this.isPlainObject_ = isPlainObject(this.target_);\r\n        if (__DEV__ && !isAnnotation(this.defaultAnnotation_)) {\r\n            die(`defaultAnnotation must be valid annotation`);\r\n        }\r\n        if (__DEV__ && typeof this.autoBind_ !== \"boolean\") {\r\n            die(`autoBind must be boolean`);\r\n        }\r\n        if (__DEV__) {\r\n            // Prepare structure for tracking which fields were already annotated\r\n            this.appliedAnnotations_ = {};\r\n        }\r\n    }\r\n    getObservablePropValue_(key) {\r\n        return this.values_.get(key).get();\r\n    }\r\n    setObservablePropValue_(key, newValue) {\r\n        const observable = this.values_.get(key);\r\n        if (observable instanceof ComputedValue) {\r\n            observable.set(newValue);\r\n            return true;\r\n        }\r\n        // intercept\r\n        if (hasInterceptors(this)) {\r\n            const change = interceptChange(this, {\r\n                type: UPDATE,\r\n                object: this.proxy_ || this.target_,\r\n                name: key,\r\n                newValue\r\n            });\r\n            if (!change)\r\n                return null;\r\n            newValue = change.newValue;\r\n        }\r\n        newValue = observable.prepareNewValue_(newValue);\r\n        // notify spy & observers\r\n        if (newValue !== globalState.UNCHANGED) {\r\n            const notify = hasListeners(this);\r\n            const notifySpy = __DEV__ && isSpyEnabled();\r\n            const change = notify || notifySpy\r\n                ? {\r\n                    type: UPDATE,\r\n                    observableKind: \"object\",\r\n                    debugObjectName: this.name_,\r\n                    object: this.proxy_ || this.target_,\r\n                    oldValue: observable.value_,\r\n                    name: key,\r\n                    newValue\r\n                }\r\n                : null;\r\n            if (__DEV__ && notifySpy)\r\n                spyReportStart(change);\r\n            observable.setNewValue_(newValue);\r\n            if (notify)\r\n                notifyListeners(this, change);\r\n            if (__DEV__ && notifySpy)\r\n                spyReportEnd();\r\n        }\r\n        return true;\r\n    }\r\n    get_(key) {\r\n        if (globalState.trackingDerivation && !hasProp(this.target_, key)) {\r\n            // Key doesn't exist yet, subscribe for it in case it's added later\r\n            this.has_(key);\r\n        }\r\n        return this.target_[key];\r\n    }\r\n    /**\r\n     * @param {PropertyKey} key\r\n     * @param {any} value\r\n     * @param {Annotation|boolean} annotation true - infer from descriptor, false - copy as is\r\n     * @param {boolean} proxyTrap whether it's called from proxy trap\r\n     * @returns {boolean|null} true on success, false on failure (proxyTrap + non-configurable), null when cancelled by interceptor\r\n     */\r\n    set_(key, value, proxyTrap = false) {\r\n        // Don't use .has(key) - we care about own\r\n        if (hasProp(this.target_, key)) {\r\n            // Existing prop\r\n            if (this.values_.has(key)) {\r\n                // Observable (can be intercepted)\r\n                return this.setObservablePropValue_(key, value);\r\n            }\r\n            else if (proxyTrap) {\r\n                // Non-observable - proxy\r\n                return Reflect.set(this.target_, key, value);\r\n            }\r\n            else {\r\n                // Non-observable\r\n                this.target_[key] = value;\r\n                return true;\r\n            }\r\n        }\r\n        else {\r\n            // New prop\r\n            return this.extend_(key, { value, enumerable: true, writable: true, configurable: true }, this.defaultAnnotation_, proxyTrap);\r\n        }\r\n    }\r\n    // Trap for \"in\"\r\n    has_(key) {\r\n        if (!globalState.trackingDerivation) {\r\n            // Skip key subscription outside derivation\r\n            return key in this.target_;\r\n        }\r\n        this.pendingKeys_ ||= new Map();\r\n        let entry = this.pendingKeys_.get(key);\r\n        if (!entry) {\r\n            entry = new ObservableValue(key in this.target_, referenceEnhancer, __DEV__ ? `${this.name_}.${stringifyKey(key)}?` : \"ObservableObject.key?\", false);\r\n            this.pendingKeys_.set(key, entry);\r\n        }\r\n        return entry.get();\r\n    }\r\n    /**\r\n     * @param {PropertyKey} key\r\n     * @param {Annotation|boolean} annotation true - infer from object or it's prototype, false - ignore\r\n     */\r\n    make_(key, annotation) {\r\n        if (annotation === true) {\r\n            annotation = this.inferAnnotation_(key);\r\n        }\r\n        if (annotation === false) {\r\n            return;\r\n        }\r\n        assertAnnotable(this, annotation, key);\r\n        annotation.make_(this, key);\r\n    }\r\n    /**\r\n     * @param {PropertyKey} key\r\n     * @param {PropertyDescriptor} descriptor\r\n     * @param {Annotation|boolean} annotation true - infer from descriptor, false - copy as is\r\n     * @param {boolean} proxyTrap whether it's called from proxy trap\r\n     * @returns {boolean|null} true on success, false on failure (proxyTrap + non-configurable), null when cancelled by interceptor\r\n     */\r\n    extend_(key, descriptor, annotation, proxyTrap = false) {\r\n        if (annotation === true) {\r\n            annotation = inferAnnotationFromDescriptor(descriptor, this.defaultAnnotation_, this.autoBind_);\r\n        }\r\n        if (annotation === false) {\r\n            return this.defineProperty_(key, descriptor, proxyTrap);\r\n        }\r\n        assertAnnotable(this, annotation, key);\r\n        const outcome = annotation.extend_(this, key, descriptor, proxyTrap);\r\n        if (outcome) {\r\n            recordAnnotationApplied(this, annotation, key);\r\n        }\r\n        return outcome;\r\n    }\r\n    inferAnnotation_(key) {\r\n        // Inherited is fine - annotation cannot differ in subclass\r\n        let annotation = this.target_[inferredAnnotationsSymbol]?.get(key);\r\n        if (annotation)\r\n            return annotation;\r\n        let current = this.target_;\r\n        while (current && current !== objectPrototype) {\r\n            const descriptor = getDescriptor(current, key);\r\n            if (descriptor) {\r\n                annotation = inferAnnotationFromDescriptor(descriptor, this.defaultAnnotation_, this.autoBind_);\r\n                break;\r\n            }\r\n            current = Object.getPrototypeOf(current);\r\n        }\r\n        // Not found (false means ignore)\r\n        if (annotation === undefined) {\r\n            die(1, \"true\", key);\r\n        }\r\n        // Cache the annotation.\r\n        // Note we can do this only because annotation and field can't change.\r\n        if (!this.isPlainObject_) {\r\n            // We could also place it on furthest proto, shoudn't matter\r\n            const closestProto = Object.getPrototypeOf(this.target_);\r\n            if (!hasProp(closestProto, inferredAnnotationsSymbol)) {\r\n                addHiddenProp(closestProto, inferredAnnotationsSymbol, new Map());\r\n            }\r\n            closestProto[inferredAnnotationsSymbol].set(key, annotation);\r\n        }\r\n        return annotation;\r\n    }\r\n    /**\r\n     * @param {PropertyKey} key\r\n     * @param {PropertyDescriptor} descriptor\r\n     * @param {boolean} proxyTrap whether it's called from proxy trap\r\n     * @returns {boolean|null} true on success, false on failure (proxyTrap + non-configurable), null when cancelled by interceptor\r\n     */\r\n    defineProperty_(key, descriptor, proxyTrap = false) {\r\n        try {\r\n            startBatch();\r\n            // Delete\r\n            const deleteOutcome = this.delete_(key);\r\n            if (!deleteOutcome) {\r\n                // Failure or intercepted\r\n                return deleteOutcome;\r\n            }\r\n            // ADD interceptor\r\n            if (hasInterceptors(this)) {\r\n                const change = interceptChange(this, {\r\n                    object: this.proxy_ || this.target_,\r\n                    name: key,\r\n                    type: ADD,\r\n                    newValue: descriptor.value\r\n                });\r\n                if (!change)\r\n                    return null;\r\n                const { newValue } = change;\r\n                if (descriptor.value !== newValue) {\r\n                    descriptor = {\r\n                        ...descriptor,\r\n                        value: newValue\r\n                    };\r\n                }\r\n            }\r\n            // Define\r\n            if (proxyTrap) {\r\n                if (!Reflect.defineProperty(this.target_, key, descriptor)) {\r\n                    return false;\r\n                }\r\n            }\r\n            else {\r\n                defineProperty(this.target_, key, descriptor);\r\n            }\r\n            // Notify\r\n            this.notifyPropertyAddition_(key, descriptor.value);\r\n        }\r\n        finally {\r\n            endBatch();\r\n        }\r\n        return true;\r\n    }\r\n    // If original descriptor becomes relevant, move this to annotation directly\r\n    defineObservableProperty_(key, value, enhancer, proxyTrap = false) {\r\n        try {\r\n            startBatch();\r\n            // Delete\r\n            const deleteOutcome = this.delete_(key);\r\n            if (!deleteOutcome) {\r\n                // Failure or intercepted\r\n                return deleteOutcome;\r\n            }\r\n            // ADD interceptor\r\n            if (hasInterceptors(this)) {\r\n                const change = interceptChange(this, {\r\n                    object: this.proxy_ || this.target_,\r\n                    name: key,\r\n                    type: ADD,\r\n                    newValue: value\r\n                });\r\n                if (!change)\r\n                    return null;\r\n                value = change.newValue;\r\n            }\r\n            const cachedDescriptor = getCachedObservablePropDescriptor(key);\r\n            const descriptor = {\r\n                configurable: globalState.safeDescriptors ? this.isPlainObject_ : true,\r\n                enumerable: true,\r\n                get: cachedDescriptor.get,\r\n                set: cachedDescriptor.set\r\n            };\r\n            // Define\r\n            if (proxyTrap) {\r\n                if (!Reflect.defineProperty(this.target_, key, descriptor)) {\r\n                    return false;\r\n                }\r\n            }\r\n            else {\r\n                defineProperty(this.target_, key, descriptor);\r\n            }\r\n            const observable = new ObservableValue(value, enhancer, __DEV__ ? `${this.name_}.${key.toString()}` : \"ObservableObject.key\", false);\r\n            this.values_.set(key, observable);\r\n            // Notify (value possibly changed by ObservableValue)\r\n            this.notifyPropertyAddition_(key, observable.value_);\r\n        }\r\n        finally {\r\n            endBatch();\r\n        }\r\n        return true;\r\n    }\r\n    // If original descriptor becomes relevant, move this to annotation directly\r\n    defineComputedProperty_(key, options, proxyTrap = false) {\r\n        try {\r\n            startBatch();\r\n            // Delete\r\n            const deleteOutcome = this.delete_(key);\r\n            if (!deleteOutcome) {\r\n                // Failure or intercepted\r\n                return deleteOutcome;\r\n            }\r\n            // ADD interceptor\r\n            if (hasInterceptors(this)) {\r\n                const change = interceptChange(this, {\r\n                    object: this.proxy_ || this.target_,\r\n                    name: key,\r\n                    type: ADD,\r\n                    newValue: undefined\r\n                });\r\n                if (!change)\r\n                    return null;\r\n            }\r\n            options.name ||= __DEV__ ? `${this.name_}.${key.toString()}` : \"ObservableObject.key\";\r\n            options.context = this.proxy_ || this.target_;\r\n            const cachedDescriptor = getCachedObservablePropDescriptor(key);\r\n            const descriptor = {\r\n                configurable: globalState.safeDescriptors ? this.isPlainObject_ : true,\r\n                enumerable: false,\r\n                get: cachedDescriptor.get,\r\n                set: cachedDescriptor.set\r\n            };\r\n            // Define\r\n            if (proxyTrap) {\r\n                if (!Reflect.defineProperty(this.target_, key, descriptor)) {\r\n                    return false;\r\n                }\r\n            }\r\n            else {\r\n                defineProperty(this.target_, key, descriptor);\r\n            }\r\n            this.values_.set(key, new ComputedValue(options));\r\n            // Notify\r\n            this.notifyPropertyAddition_(key, undefined);\r\n        }\r\n        finally {\r\n            endBatch();\r\n        }\r\n        return true;\r\n    }\r\n    /**\r\n     * @param {PropertyKey} key\r\n     * @param {PropertyDescriptor} descriptor\r\n     * @param {boolean} proxyTrap whether it's called from proxy trap\r\n     * @returns {boolean|null} true on success, false on failure (proxyTrap + non-configurable), null when cancelled by interceptor\r\n     */\r\n    delete_(key, proxyTrap = false) {\r\n        // No such prop\r\n        if (!hasProp(this.target_, key)) {\r\n            return true;\r\n        }\r\n        // Intercept\r\n        if (hasInterceptors(this)) {\r\n            const change = interceptChange(this, {\r\n                object: this.proxy_ || this.target_,\r\n                name: key,\r\n                type: REMOVE\r\n            });\r\n            // Cancelled\r\n            if (!change)\r\n                return null;\r\n        }\r\n        // Delete\r\n        try {\r\n            startBatch();\r\n            const notify = hasListeners(this);\r\n            const notifySpy = __DEV__ && isSpyEnabled();\r\n            const observable = this.values_.get(key);\r\n            // Value needed for spies/listeners\r\n            let value = undefined;\r\n            // Optimization: don't pull the value unless we will need it\r\n            if (!observable && (notify || notifySpy)) {\r\n                value = getDescriptor(this.target_, key)?.value;\r\n            }\r\n            // delete prop (do first, may fail)\r\n            if (proxyTrap) {\r\n                if (!Reflect.deleteProperty(this.target_, key)) {\r\n                    return false;\r\n                }\r\n            }\r\n            else {\r\n                delete this.target_[key];\r\n            }\r\n            // Allow re-annotating this field\r\n            if (__DEV__) {\r\n                delete this.appliedAnnotations_[key];\r\n            }\r\n            // Clear observable\r\n            if (observable) {\r\n                this.values_.delete(key);\r\n                // for computed, value is undefined\r\n                if (observable instanceof ObservableValue) {\r\n                    value = observable.value_;\r\n                }\r\n                // Notify: autorun(() => obj[key]), see #1796\r\n                propagateChanged(observable);\r\n            }\r\n            // Notify \"keys/entries/values\" observers\r\n            this.keysAtom_.reportChanged();\r\n            // Notify \"has\" observers\r\n            // \"in\" as it may still exist in proto\r\n            this.pendingKeys_?.get(key)?.set(key in this.target_);\r\n            // Notify spies/listeners\r\n            if (notify || notifySpy) {\r\n                const change = {\r\n                    type: REMOVE,\r\n                    observableKind: \"object\",\r\n                    object: this.proxy_ || this.target_,\r\n                    debugObjectName: this.name_,\r\n                    oldValue: value,\r\n                    name: key\r\n                };\r\n                if (__DEV__ && notifySpy)\r\n                    spyReportStart(change);\r\n                if (notify)\r\n                    notifyListeners(this, change);\r\n                if (__DEV__ && notifySpy)\r\n                    spyReportEnd();\r\n            }\r\n        }\r\n        finally {\r\n            endBatch();\r\n        }\r\n        return true;\r\n    }\r\n    /**\r\n     * Observes this object. Triggers for the events 'add', 'update' and 'delete'.\r\n     * See: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/observe\r\n     * for callback details\r\n     */\r\n    observe_(callback, fireImmediately) {\r\n        if (__DEV__ && fireImmediately === true)\r\n            die(\"`observe` doesn't support the fire immediately property for observable objects.\");\r\n        return registerListener(this, callback);\r\n    }\r\n    intercept_(handler) {\r\n        return registerInterceptor(this, handler);\r\n    }\r\n    notifyPropertyAddition_(key, value) {\r\n        const notify = hasListeners(this);\r\n        const notifySpy = __DEV__ && isSpyEnabled();\r\n        if (notify || notifySpy) {\r\n            const change = notify || notifySpy\r\n                ? {\r\n                    type: ADD,\r\n                    observableKind: \"object\",\r\n                    debugObjectName: this.name_,\r\n                    object: this.proxy_ || this.target_,\r\n                    name: key,\r\n                    newValue: value\r\n                }\r\n                : null;\r\n            if (__DEV__ && notifySpy)\r\n                spyReportStart(change);\r\n            if (notify)\r\n                notifyListeners(this, change);\r\n            if (__DEV__ && notifySpy)\r\n                spyReportEnd();\r\n        }\r\n        this.pendingKeys_?.get(key)?.set(true);\r\n        // Notify \"keys/entries/values\" observers\r\n        this.keysAtom_.reportChanged();\r\n    }\r\n    ownKeys_() {\r\n        this.keysAtom_.reportObserved();\r\n        return ownKeys(this.target_);\r\n    }\r\n    keys_() {\r\n        // Returns enumerable && own, but unfortunately keysAtom will report on ANY key change.\r\n        // There is no way to distinguish between Object.keys(object) and Reflect.ownKeys(object) - both are handled by ownKeys trap.\r\n        // We can either over-report in Object.keys(object) or under-report in Reflect.ownKeys(object)\r\n        // We choose to over-report in Object.keys(object), because:\r\n        // - typically it's used with simple data objects\r\n        // - when symbolic/non-enumerable keys are relevant Reflect.ownKeys works as expected\r\n        this.keysAtom_.reportObserved();\r\n        return Object.keys(this.target_);\r\n    }\r\n}\r\nexport function asObservableObject(target, options) {\r\n    if (__DEV__ && options && isObservableObject(target)) {\r\n        die(`Options can't be provided for already observable objects.`);\r\n    }\r\n    if (hasProp(target, $mobx)) {\r\n        if (__DEV__ && !(getAdministration(target) instanceof ObservableObjectAdministration)) {\r\n            die(`Cannot convert '${getDebugName(target)}' into observable object:` +\r\n                `\\nThe target is already observable of different type.` +\r\n                `\\nExtending builtins is not supported.`);\r\n        }\r\n        return target;\r\n    }\r\n    if (__DEV__ && !Object.isExtensible(target))\r\n        die(\"Cannot make the designated object observable; it is not extensible\");\r\n    const name = options?.name ??\r\n        (__DEV__\r\n            ? `${isPlainObject(target) ? \"ObservableObject\" : target.constructor.name}@${getNextId()}`\r\n            : \"ObservableObject\");\r\n    const adm = new ObservableObjectAdministration(target, new Map(), String(name), getAnnotationFromOptions(options), options?.autoBind);\r\n    addHiddenProp(target, $mobx, adm);\r\n    return target;\r\n}\r\nconst isObservableObjectAdministration = createInstanceofPredicate(\"ObservableObjectAdministration\", ObservableObjectAdministration);\r\nfunction getCachedObservablePropDescriptor(key) {\r\n    return (descriptorCache[key] ||\r\n        (descriptorCache[key] = {\r\n            get() {\r\n                return this[$mobx].getObservablePropValue_(key);\r\n            },\r\n            set(value) {\r\n                return this[$mobx].setObservablePropValue_(key, value);\r\n            }\r\n        }));\r\n}\r\nexport function isObservableObject(thing) {\r\n    if (isObject(thing)) {\r\n        return isObservableObjectAdministration(thing[$mobx]);\r\n    }\r\n    return false;\r\n}\r\nexport function recordAnnotationApplied(adm, annotation, key) {\r\n    if (__DEV__) {\r\n        adm.appliedAnnotations_[key] = annotation;\r\n    }\r\n    // Remove applied decorator annotation so we don't try to apply it again in subclass constructor\r\n    delete adm.target_[storedAnnotationsSymbol]?.[key];\r\n}\r\nfunction assertAnnotable(adm, annotation, key) {\r\n    // Valid annotation\r\n    if (__DEV__ && !isAnnotation(annotation)) {\r\n        die(`Cannot annotate '${adm.name_}.${key.toString()}': Invalid annotation.`);\r\n    }\r\n    /*\r\n    // Configurable, not sealed, not frozen\r\n    // Possibly not needed, just a little better error then the one thrown by engine.\r\n    // Cases where this would be useful the most (subclass field initializer) are not interceptable by this.\r\n    if (__DEV__) {\r\n        const configurable = getDescriptor(adm.target_, key)?.configurable\r\n        const frozen = Object.isFrozen(adm.target_)\r\n        const sealed = Object.isSealed(adm.target_)\r\n        if (!configurable || frozen || sealed) {\r\n            const fieldName = `${adm.name_}.${key.toString()}`\r\n            const requestedAnnotationType = annotation.annotationType_\r\n            let error = `Cannot apply '${requestedAnnotationType}' to '${fieldName}':`\r\n            if (frozen) {\r\n                error += `\\nObject is frozen.`\r\n            }\r\n            if (sealed) {\r\n                error += `\\nObject is sealed.`\r\n            }\r\n            if (!configurable) {\r\n                error += `\\nproperty is not configurable.`\r\n                // Mention only if caused by us to avoid confusion\r\n                if (hasProp(adm.appliedAnnotations!, key)) {\r\n                    error += `\\nTo prevent accidental re-definition of a field by a subclass, `\r\n                    error += `all annotated fields of non-plain objects (classes) are not configurable.`\r\n                }\r\n            }\r\n            die(error)\r\n        }\r\n    }\r\n    */\r\n    // Not annotated\r\n    if (__DEV__ && !isOverride(annotation) && hasProp(adm.appliedAnnotations_, key)) {\r\n        const fieldName = `${adm.name_}.${key.toString()}`;\r\n        const currentAnnotationType = adm.appliedAnnotations_[key].annotationType_;\r\n        const requestedAnnotationType = annotation.annotationType_;\r\n        die(`Cannot apply '${requestedAnnotationType}' to '${fieldName}':` +\r\n            `\\nThe field is already annotated with '${currentAnnotationType}'.` +\r\n            `\\nRe-annotating fields is not allowed.` +\r\n            `\\nUse 'override' annotation for methods overriden by subclass.`);\r\n    }\r\n}\r\n//# sourceMappingURL=observableobject.js.map","references":["/Users/sergeigolishnikov/development/web/mobx/packages/mobx/src/internal.ts"],"map":"{\"version\":3,\"file\":\"observableobject.js\",\"sourceRoot\":\"\",\"sources\":[\"../../../../../src/types/observableobject.ts\"],\"names\":[],\"mappings\":\"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\"}"}
