{"code":"import { ComputedValue, IDerivationState_, TraceMode, getDependencyTree, globalState, runReactions, checkIfStateReadsAreAllowed } from \"../internal\";\r\nexport function hasObservers(observable) {\r\n    return observable.observers_ && observable.observers_.size > 0;\r\n}\r\nexport function getObservers(observable) {\r\n    return observable.observers_;\r\n}\r\n// function invariantObservers(observable: IObservable) {\r\n//     const list = observable.observers\r\n//     const map = observable.observersIndexes\r\n//     const l = list.length\r\n//     for (let i = 0; i < l; i++) {\r\n//         const id = list[i].__mapid\r\n//         if (i) {\r\n//             invariant(map[id] === i, \"INTERNAL ERROR maps derivation.__mapid to index in list\") // for performance\r\n//         } else {\r\n//             invariant(!(id in map), \"INTERNAL ERROR observer on index 0 shouldn't be held in map.\") // for performance\r\n//         }\r\n//     }\r\n//     invariant(\r\n//         list.length === 0 || Object.keys(map).length === list.length - 1,\r\n//         \"INTERNAL ERROR there is no junk in map\"\r\n//     )\r\n// }\r\nexport function addObserver(observable, node) {\r\n    // invariant(node.dependenciesState !== -1, \"INTERNAL ERROR, can add only dependenciesState !== -1\");\r\n    // invariant(observable._observers.indexOf(node) === -1, \"INTERNAL ERROR add already added node\");\r\n    // invariantObservers(observable);\r\n    observable.observers_.add(node);\r\n    if (observable.lowestObserverState_ > node.dependenciesState_)\r\n        observable.lowestObserverState_ = node.dependenciesState_;\r\n    // invariantObservers(observable);\r\n    // invariant(observable._observers.indexOf(node) !== -1, \"INTERNAL ERROR didn't add node\");\r\n}\r\nexport function removeObserver(observable, node) {\r\n    // invariant(globalState.inBatch > 0, \"INTERNAL ERROR, remove should be called only inside batch\");\r\n    // invariant(observable._observers.indexOf(node) !== -1, \"INTERNAL ERROR remove already removed node\");\r\n    // invariantObservers(observable);\r\n    observable.observers_.delete(node);\r\n    if (observable.observers_.size === 0) {\r\n        // deleting last observer\r\n        queueForUnobservation(observable);\r\n    }\r\n    // invariantObservers(observable);\r\n    // invariant(observable._observers.indexOf(node) === -1, \"INTERNAL ERROR remove already removed node2\");\r\n}\r\nexport function queueForUnobservation(observable) {\r\n    if (observable.isPendingUnobservation_ === false) {\r\n        // invariant(observable._observers.length === 0, \"INTERNAL ERROR, should only queue for unobservation unobserved observables\");\r\n        observable.isPendingUnobservation_ = true;\r\n        globalState.pendingUnobservations.push(observable);\r\n    }\r\n}\r\n/**\r\n * Batch starts a transaction, at least for purposes of memoizing ComputedValues when nothing else does.\r\n * During a batch `onBecomeUnobserved` will be called at most once per observable.\r\n * Avoids unnecessary recalculations.\r\n */\r\nexport function startBatch() {\r\n    globalState.inBatch++;\r\n}\r\nexport function endBatch() {\r\n    if (--globalState.inBatch === 0) {\r\n        runReactions();\r\n        // the batch is actually about to finish, all unobserving should happen here.\r\n        const list = globalState.pendingUnobservations;\r\n        for (let i = 0; i < list.length; i++) {\r\n            const observable = list[i];\r\n            observable.isPendingUnobservation_ = false;\r\n            if (observable.observers_.size === 0) {\r\n                if (observable.isBeingObserved_) {\r\n                    // if this observable had reactive observers, trigger the hooks\r\n                    observable.isBeingObserved_ = false;\r\n                    observable.onBUO();\r\n                }\r\n                if (observable instanceof ComputedValue) {\r\n                    // computed values are automatically teared down when the last observer leaves\r\n                    // this process happens recursively, this computed might be the last observabe of another, etc..\r\n                    observable.suspend_();\r\n                }\r\n            }\r\n        }\r\n        globalState.pendingUnobservations = [];\r\n    }\r\n}\r\nexport function reportObserved(observable) {\r\n    checkIfStateReadsAreAllowed(observable);\r\n    const derivation = globalState.trackingDerivation;\r\n    if (derivation !== null) {\r\n        /**\r\n         * Simple optimization, give each derivation run an unique id (runId)\r\n         * Check if last time this observable was accessed the same runId is used\r\n         * if this is the case, the relation is already known\r\n         */\r\n        if (derivation.runId_ !== observable.lastAccessedBy_) {\r\n            observable.lastAccessedBy_ = derivation.runId_;\r\n            // Tried storing newObserving, or observing, or both as Set, but performance didn't come close...\r\n            derivation.newObserving_[derivation.unboundDepsCount_++] = observable;\r\n            if (!observable.isBeingObserved_ && globalState.trackingContext) {\r\n                observable.isBeingObserved_ = true;\r\n                observable.onBO();\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n    else if (observable.observers_.size === 0 && globalState.inBatch > 0) {\r\n        queueForUnobservation(observable);\r\n    }\r\n    return false;\r\n}\r\n// function invariantLOS(observable: IObservable, msg: string) {\r\n//     // it's expensive so better not run it in produciton. but temporarily helpful for testing\r\n//     const min = getObservers(observable).reduce((a, b) => Math.min(a, b.dependenciesState), 2)\r\n//     if (min >= observable.lowestObserverState) return // <- the only assumption about `lowestObserverState`\r\n//     throw new Error(\r\n//         \"lowestObserverState is wrong for \" +\r\n//             msg +\r\n//             \" because \" +\r\n//             min +\r\n//             \" < \" +\r\n//             observable.lowestObserverState\r\n//     )\r\n// }\r\n/**\r\n * NOTE: current propagation mechanism will in case of self reruning autoruns behave unexpectedly\r\n * It will propagate changes to observers from previous run\r\n * It's hard or maybe impossible (with reasonable perf) to get it right with current approach\r\n * Hopefully self reruning autoruns aren't a feature people should depend on\r\n * Also most basic use cases should be ok\r\n */\r\n// Called by Atom when its value changes\r\nexport function propagateChanged(observable) {\r\n    // invariantLOS(observable, \"changed start\");\r\n    if (observable.lowestObserverState_ === IDerivationState_.STALE_)\r\n        return;\r\n    observable.lowestObserverState_ = IDerivationState_.STALE_;\r\n    // Ideally we use for..of here, but the downcompiled version is really slow...\r\n    observable.observers_.forEach(d => {\r\n        if (d.dependenciesState_ === IDerivationState_.UP_TO_DATE_) {\r\n            if (__DEV__ && d.isTracing_ !== TraceMode.NONE) {\r\n                logTraceInfo(d, observable);\r\n            }\r\n            d.onBecomeStale_();\r\n        }\r\n        d.dependenciesState_ = IDerivationState_.STALE_;\r\n    });\r\n    // invariantLOS(observable, \"changed end\");\r\n}\r\n// Called by ComputedValue when it recalculate and its value changed\r\nexport function propagateChangeConfirmed(observable) {\r\n    // invariantLOS(observable, \"confirmed start\");\r\n    if (observable.lowestObserverState_ === IDerivationState_.STALE_)\r\n        return;\r\n    observable.lowestObserverState_ = IDerivationState_.STALE_;\r\n    observable.observers_.forEach(d => {\r\n        if (d.dependenciesState_ === IDerivationState_.POSSIBLY_STALE_)\r\n            d.dependenciesState_ = IDerivationState_.STALE_;\r\n        else if (d.dependenciesState_ === IDerivationState_.UP_TO_DATE_ // this happens during computing of `d`, just keep lowestObserverState up to date.\r\n        )\r\n            observable.lowestObserverState_ = IDerivationState_.UP_TO_DATE_;\r\n    });\r\n    // invariantLOS(observable, \"confirmed end\");\r\n}\r\n// Used by computed when its dependency changed, but we don't wan't to immediately recompute.\r\nexport function propagateMaybeChanged(observable) {\r\n    // invariantLOS(observable, \"maybe start\");\r\n    if (observable.lowestObserverState_ !== IDerivationState_.UP_TO_DATE_)\r\n        return;\r\n    observable.lowestObserverState_ = IDerivationState_.POSSIBLY_STALE_;\r\n    observable.observers_.forEach(d => {\r\n        if (d.dependenciesState_ === IDerivationState_.UP_TO_DATE_) {\r\n            d.dependenciesState_ = IDerivationState_.POSSIBLY_STALE_;\r\n            if (__DEV__ && d.isTracing_ !== TraceMode.NONE) {\r\n                logTraceInfo(d, observable);\r\n            }\r\n            d.onBecomeStale_();\r\n        }\r\n    });\r\n    // invariantLOS(observable, \"maybe end\");\r\n}\r\nfunction logTraceInfo(derivation, observable) {\r\n    console.log(`[mobx.trace] '${derivation.name_}' is invalidated due to a change in: '${observable.name_}'`);\r\n    if (derivation.isTracing_ === TraceMode.BREAK) {\r\n        const lines = [];\r\n        printDepTree(getDependencyTree(derivation), lines, 1);\r\n        // prettier-ignore\r\n        new Function(`debugger;\n/*\nTracing '${derivation.name_}'\n\nYou are entering this break point because derivation '${derivation.name_}' is being traced and '${observable.name_}' is now forcing it to update.\nJust follow the stacktrace you should now see in the devtools to see precisely what piece of your code is causing this update\nThe stackframe you are looking for is at least ~6-8 stack-frames up.\n\n${derivation instanceof ComputedValue ? derivation.derivation.toString().replace(/[*]\\//g, \"/\") : \"\"}\n\nThe dependencies for this derivation are:\n\n${lines.join(\"\\n\")}\n*/\n    `)();\r\n    }\r\n}\r\nfunction printDepTree(tree, lines, depth) {\r\n    if (lines.length >= 1000) {\r\n        lines.push(\"(and many more)\");\r\n        return;\r\n    }\r\n    lines.push(`${new Array(depth).join(\"\\t\")}${tree.name}`); // MWE: not the fastest, but the easiest way :)\r\n    if (tree.dependencies)\r\n        tree.dependencies.forEach(child => printDepTree(child, lines, depth + 1));\r\n}\r\n//# sourceMappingURL=observable.js.map","references":["/Users/sergeigolishnikov/development/web/mobx/packages/mobx/src/internal.ts"],"map":"{\"version\":3,\"file\":\"observable.js\",\"sourceRoot\":\"\",\"sources\":[\"../../../../../src/core/observable.ts\"],\"names\":[],\"mappings\":\"AAAA,OAAO,EAEH,aAAa,EAGb,iBAAiB,EACjB,SAAS,EACT,iBAAiB,EACjB,WAAW,EACX,YAAY,EACZ,2BAA2B,EAC9B,MAAM,aAAa,CAAA;AA6BpB,MAAM,UAAU,YAAY,CAAC,UAAuB;IAChD,OAAO,UAAU,CAAC,UAAU,IAAI,UAAU,CAAC,UAAU,CAAC,IAAI,GAAG,CAAC,CAAA;AAClE,CAAC;AAED,MAAM,UAAU,YAAY,CAAC,UAAuB;IAChD,OAAO,UAAU,CAAC,UAAU,CAAA;AAChC,CAAC;AAED,yDAAyD;AACzD,wCAAwC;AACxC,8CAA8C;AAC9C,4BAA4B;AAC5B,oCAAoC;AACpC,qCAAqC;AACrC,mBAAmB;AACnB,qHAAqH;AACrH,mBAAmB;AACnB,yHAAyH;AACzH,YAAY;AACZ,QAAQ;AACR,iBAAiB;AACjB,4EAA4E;AAC5E,mDAAmD;AACnD,QAAQ;AACR,IAAI;AACJ,MAAM,UAAU,WAAW,CAAC,UAAuB,EAAE,IAAiB;IAClE,qGAAqG;IACrG,kGAAkG;IAClG,kCAAkC;IAElC,UAAU,CAAC,UAAU,CAAC,GAAG,CAAC,IAAI,CAAC,CAAA;IAC/B,IAAI,UAAU,CAAC,oBAAoB,GAAG,IAAI,CAAC,kBAAkB;QACzD,UAAU,CAAC,oBAAoB,GAAG,IAAI,CAAC,kBAAkB,CAAA;IAE7D,kCAAkC;IAClC,2FAA2F;AAC/F,CAAC;AAED,MAAM,UAAU,cAAc,CAAC,UAAuB,EAAE,IAAiB;IACrE,mGAAmG;IACnG,uGAAuG;IACvG,kCAAkC;IAClC,UAAU,CAAC,UAAU,CAAC,MAAM,CAAC,IAAI,CAAC,CAAA;IAClC,IAAI,UAAU,CAAC,UAAU,CAAC,IAAI,KAAK,CAAC,EAAE;QAClC,yBAAyB;QACzB,qBAAqB,CAAC,UAAU,CAAC,CAAA;KACpC;IACD,kCAAkC;IAClC,wGAAwG;AAC5G,CAAC;AAED,MAAM,UAAU,qBAAqB,CAAC,UAAuB;IACzD,IAAI,UAAU,CAAC,uBAAuB,KAAK,KAAK,EAAE;QAC9C,+HAA+H;QAC/H,UAAU,CAAC,uBAAuB,GAAG,IAAI,CAAA;QACzC,WAAW,CAAC,qBAAqB,CAAC,IAAI,CAAC,UAAU,CAAC,CAAA;KACrD;AACL,CAAC;AAED;;;;GAIG;AACH,MAAM,UAAU,UAAU;IACtB,WAAW,CAAC,OAAO,EAAE,CAAA;AACzB,CAAC;AAED,MAAM,UAAU,QAAQ;IACpB,IAAI,EAAE,WAAW,CAAC,OAAO,KAAK,CAAC,EAAE;QAC7B,YAAY,EAAE,CAAA;QACd,6EAA6E;QAC7E,MAAM,IAAI,GAAG,WAAW,CAAC,qBAAqB,CAAA;QAC9C,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,IAAI,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;YAClC,MAAM,UAAU,GAAG,IAAI,CAAC,CAAC,CAAC,CAAA;YAC1B,UAAU,CAAC,uBAAuB,GAAG,KAAK,CAAA;YAC1C,IAAI,UAAU,CAAC,UAAU,CAAC,IAAI,KAAK,CAAC,EAAE;gBAClC,IAAI,UAAU,CAAC,gBAAgB,EAAE;oBAC7B,+DAA+D;oBAC/D,UAAU,CAAC,gBAAgB,GAAG,KAAK,CAAA;oBACnC,UAAU,CAAC,KAAK,EAAE,CAAA;iBACrB;gBACD,IAAI,UAAU,YAAY,aAAa,EAAE;oBACrC,8EAA8E;oBAC9E,gGAAgG;oBAChG,UAAU,CAAC,QAAQ,EAAE,CAAA;iBACxB;aACJ;SACJ;QACD,WAAW,CAAC,qBAAqB,GAAG,EAAE,CAAA;KACzC;AACL,CAAC;AAED,MAAM,UAAU,cAAc,CAAC,UAAuB;IAClD,2BAA2B,CAAC,UAAU,CAAC,CAAA;IAEvC,MAAM,UAAU,GAAG,WAAW,CAAC,kBAAkB,CAAA;IACjD,IAAI,UAAU,KAAK,IAAI,EAAE;QACrB;;;;WAIG;QACH,IAAI,UAAU,CAAC,MAAM,KAAK,UAAU,CAAC,eAAe,EAAE;YAClD,UAAU,CAAC,eAAe,GAAG,UAAU,CAAC,MAAM,CAAA;YAC9C,iGAAiG;YACjG,UAAU,CAAC,aAAc,CAAC,UAAU,CAAC,iBAAiB,EAAE,CAAC,GAAG,UAAU,CAAA;YACtE,IAAI,CAAC,UAAU,CAAC,gBAAgB,IAAI,WAAW,CAAC,eAAe,EAAE;gBAC7D,UAAU,CAAC,gBAAgB,GAAG,IAAI,CAAA;gBAClC,UAAU,CAAC,IAAI,EAAE,CAAA;aACpB;SACJ;QACD,OAAO,IAAI,CAAA;KACd;SAAM,IAAI,UAAU,CAAC,UAAU,CAAC,IAAI,KAAK,CAAC,IAAI,WAAW,CAAC,OAAO,GAAG,CAAC,EAAE;QACpE,qBAAqB,CAAC,UAAU,CAAC,CAAA;KACpC;IAED,OAAO,KAAK,CAAA;AAChB,CAAC;AAED,gEAAgE;AAChE,gGAAgG;AAChG,iGAAiG;AACjG,8GAA8G;AAC9G,uBAAuB;AACvB,gDAAgD;AAChD,oBAAoB;AACpB,4BAA4B;AAC5B,oBAAoB;AACpB,sBAAsB;AACtB,6CAA6C;AAC7C,QAAQ;AACR,IAAI;AAEJ;;;;;;GAMG;AAEH,wCAAwC;AACxC,MAAM,UAAU,gBAAgB,CAAC,UAAuB;IACpD,6CAA6C;IAC7C,IAAI,UAAU,CAAC,oBAAoB,KAAK,iBAAiB,CAAC,MAAM;QAAE,OAAM;IACxE,UAAU,CAAC,oBAAoB,GAAG,iBAAiB,CAAC,MAAM,CAAA;IAE1D,8EAA8E;IAC9E,UAAU,CAAC,UAAU,CAAC,OAAO,CAAC,CAAC,CAAC,EAAE;QAC9B,IAAI,CAAC,CAAC,kBAAkB,KAAK,iBAAiB,CAAC,WAAW,EAAE;YACxD,IAAI,OAAO,IAAI,CAAC,CAAC,UAAU,KAAK,SAAS,CAAC,IAAI,EAAE;gBAC5C,YAAY,CAAC,CAAC,EAAE,UAAU,CAAC,CAAA;aAC9B;YACD,CAAC,CAAC,cAAc,EAAE,CAAA;SACrB;QACD,CAAC,CAAC,kBAAkB,GAAG,iBAAiB,CAAC,MAAM,CAAA;IACnD,CAAC,CAAC,CAAA;IACF,2CAA2C;AAC/C,CAAC;AAED,oEAAoE;AACpE,MAAM,UAAU,wBAAwB,CAAC,UAAuB;IAC5D,+CAA+C;IAC/C,IAAI,UAAU,CAAC,oBAAoB,KAAK,iBAAiB,CAAC,MAAM;QAAE,OAAM;IACxE,UAAU,CAAC,oBAAoB,GAAG,iBAAiB,CAAC,MAAM,CAAA;IAE1D,UAAU,CAAC,UAAU,CAAC,OAAO,CAAC,CAAC,CAAC,EAAE;QAC9B,IAAI,CAAC,CAAC,kBAAkB,KAAK,iBAAiB,CAAC,eAAe;YAC1D,CAAC,CAAC,kBAAkB,GAAG,iBAAiB,CAAC,MAAM,CAAA;aAC9C,IACD,CAAC,CAAC,kBAAkB,KAAK,iBAAiB,CAAC,WAAW,CAAC,kFAAkF;;YAEzI,UAAU,CAAC,oBAAoB,GAAG,iBAAiB,CAAC,WAAW,CAAA;IACvE,CAAC,CAAC,CAAA;IACF,6CAA6C;AACjD,CAAC;AAED,6FAA6F;AAC7F,MAAM,UAAU,qBAAqB,CAAC,UAAuB;IACzD,2CAA2C;IAC3C,IAAI,UAAU,CAAC,oBAAoB,KAAK,iBAAiB,CAAC,WAAW;QAAE,OAAM;IAC7E,UAAU,CAAC,oBAAoB,GAAG,iBAAiB,CAAC,eAAe,CAAA;IAEnE,UAAU,CAAC,UAAU,CAAC,OAAO,CAAC,CAAC,CAAC,EAAE;QAC9B,IAAI,CAAC,CAAC,kBAAkB,KAAK,iBAAiB,CAAC,WAAW,EAAE;YACxD,CAAC,CAAC,kBAAkB,GAAG,iBAAiB,CAAC,eAAe,CAAA;YACxD,IAAI,OAAO,IAAI,CAAC,CAAC,UAAU,KAAK,SAAS,CAAC,IAAI,EAAE;gBAC5C,YAAY,CAAC,CAAC,EAAE,UAAU,CAAC,CAAA;aAC9B;YACD,CAAC,CAAC,cAAc,EAAE,CAAA;SACrB;IACL,CAAC,CAAC,CAAA;IACF,yCAAyC;AAC7C,CAAC;AAED,SAAS,YAAY,CAAC,UAAuB,EAAE,UAAuB;IAClE,OAAO,CAAC,GAAG,CACP,iBAAiB,UAAU,CAAC,KAAK,yCAAyC,UAAU,CAAC,KAAK,GAAG,CAChG,CAAA;IACD,IAAI,UAAU,CAAC,UAAU,KAAK,SAAS,CAAC,KAAK,EAAE;QAC3C,MAAM,KAAK,GAAG,EAAE,CAAA;QAChB,YAAY,CAAC,iBAAiB,CAAC,UAAU,CAAC,EAAE,KAAK,EAAE,CAAC,CAAC,CAAA;QAErD,kBAAkB;QAClB,IAAI,QAAQ,CACpB;;WAEW,UAAU,CAAC,KAAK;;wDAE6B,UAAU,CAAC,KAAK,0BAA0B,UAAU,CAAC,KAAK;;;;EAIhH,UAAU,YAAY,aAAa,CAAC,CAAC,CAAC,UAAU,CAAC,UAAU,CAAC,QAAQ,EAAE,CAAC,OAAO,CAAC,QAAQ,EAAE,GAAG,CAAC,CAAC,CAAC,CAAC,EAAE;;;;EAIlG,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC;;KAEb,CAAC,EAAE,CAAA;KACH;AACL,CAAC;AAED,SAAS,YAAY,CAAC,IAAqB,EAAE,KAAe,EAAE,KAAa;IACvE,IAAI,KAAK,CAAC,MAAM,IAAI,IAAI,EAAE;QACtB,KAAK,CAAC,IAAI,CAAC,iBAAiB,CAAC,CAAA;QAC7B,OAAM;KACT;IACD,KAAK,CAAC,IAAI,CAAC,GAAG,IAAI,KAAK,CAAC,KAAK,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,GAAG,IAAI,CAAC,IAAI,EAAE,CAAC,CAAA,CAAC,+CAA+C;IACxG,IAAI,IAAI,CAAC,YAAY;QAAE,IAAI,CAAC,YAAY,CAAC,OAAO,CAAC,KAAK,CAAC,EAAE,CAAC,YAAY,CAAC,KAAK,EAAE,KAAK,EAAE,KAAK,GAAG,CAAC,CAAC,CAAC,CAAA;AACpG,CAAC\"}"}
