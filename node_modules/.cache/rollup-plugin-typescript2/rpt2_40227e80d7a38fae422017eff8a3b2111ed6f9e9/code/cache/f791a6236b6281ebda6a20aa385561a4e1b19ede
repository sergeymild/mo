{"code":"import { IDerivationState_, createInstanceofPredicate, endBatch, getNextId, noop, onBecomeObserved, onBecomeUnobserved, propagateChanged, reportObserved, startBatch } from \"../internal\";\r\nexport const $mobx = Symbol(\"mobx administration\");\r\nexport class Atom {\r\n    name_;\r\n    isPendingUnobservation_ = false; // for effective unobserving. BaseAtom has true, for extra optimization, so its onBecomeUnobserved never gets called, because it's not needed\r\n    isBeingObserved_ = false;\r\n    observers_ = new Set();\r\n    diffValue_ = 0;\r\n    lastAccessedBy_ = 0;\r\n    lowestObserverState_ = IDerivationState_.NOT_TRACKING_;\r\n    /**\r\n     * Create a new atom. For debugging purposes it is recommended to give it a name.\r\n     * The onBecomeObserved and onBecomeUnobserved callbacks can be used for resource management.\r\n     */\r\n    constructor(name_ = __DEV__ ? \"Atom@\" + getNextId() : \"Atom\") {\r\n        this.name_ = name_;\r\n    }\r\n    // onBecomeObservedListeners\r\n    onBOL;\r\n    // onBecomeUnobservedListeners\r\n    onBUOL;\r\n    onBO() {\r\n        if (this.onBOL) {\r\n            this.onBOL.forEach(listener => listener());\r\n        }\r\n    }\r\n    onBUO() {\r\n        if (this.onBUOL) {\r\n            this.onBUOL.forEach(listener => listener());\r\n        }\r\n    }\r\n    /**\r\n     * Invoke this method to notify mobx that your atom has been used somehow.\r\n     * Returns true if there is currently a reactive context.\r\n     */\r\n    reportObserved() {\r\n        return reportObserved(this);\r\n    }\r\n    /**\r\n     * Invoke this method _after_ this method has changed to signal mobx that all its observers should invalidate.\r\n     */\r\n    reportChanged() {\r\n        startBatch();\r\n        propagateChanged(this);\r\n        endBatch();\r\n    }\r\n    toString() {\r\n        return this.name_;\r\n    }\r\n}\r\nexport const isAtom = createInstanceofPredicate(\"Atom\", Atom);\r\nexport function createAtom(name, onBecomeObservedHandler = noop, onBecomeUnobservedHandler = noop) {\r\n    const atom = new Atom(name);\r\n    // default `noop` listener will not initialize the hook Set\r\n    if (onBecomeObservedHandler !== noop) {\r\n        onBecomeObserved(atom, onBecomeObservedHandler);\r\n    }\r\n    if (onBecomeUnobservedHandler !== noop) {\r\n        onBecomeUnobserved(atom, onBecomeUnobservedHandler);\r\n    }\r\n    return atom;\r\n}\r\n//# sourceMappingURL=atom.js.map","references":["/Users/sergeigolishnikov/development/web/mobx/packages/mobx/src/internal.ts"],"map":"{\"version\":3,\"file\":\"atom.js\",\"sourceRoot\":\"\",\"sources\":[\"../../../../../src/core/atom.ts\"],\"names\":[],\"mappings\":\"AAAA,OAAO,EACH,iBAAiB,EAGjB,yBAAyB,EACzB,QAAQ,EACR,SAAS,EACT,IAAI,EACJ,gBAAgB,EAChB,kBAAkB,EAClB,gBAAgB,EAChB,cAAc,EACd,UAAU,EAEb,MAAM,aAAa,CAAA;AAEpB,MAAM,CAAC,MAAM,KAAK,GAAG,MAAM,CAAC,qBAAqB,CAAC,CAAA;AAOlD,MAAM,OAAO,IAAI;IAYM;IAXnB,uBAAuB,GAAG,KAAK,CAAA,CAAC,6IAA6I;IAC7K,gBAAgB,GAAG,KAAK,CAAA;IACxB,UAAU,GAAG,IAAI,GAAG,EAAe,CAAA;IAEnC,UAAU,GAAG,CAAC,CAAA;IACd,eAAe,GAAG,CAAC,CAAA;IACnB,oBAAoB,GAAG,iBAAiB,CAAC,aAAa,CAAA;IACtD;;;OAGG;IACH,YAAmB,QAAQ,OAAO,CAAC,CAAC,CAAC,OAAO,GAAG,SAAS,EAAE,CAAC,CAAC,CAAC,MAAM;QAAhD,UAAK,GAAL,KAAK,CAA2C;IAAG,CAAC;IAEvE,4BAA4B;IACrB,KAAK,CAAyB;IACrC,8BAA8B;IACvB,MAAM,CAAyB;IAE/B,IAAI;QACP,IAAI,IAAI,CAAC,KAAK,EAAE;YACZ,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,QAAQ,CAAC,EAAE,CAAC,QAAQ,EAAE,CAAC,CAAA;SAC7C;IACL,CAAC;IAEM,KAAK;QACR,IAAI,IAAI,CAAC,MAAM,EAAE;YACb,IAAI,CAAC,MAAM,CAAC,OAAO,CAAC,QAAQ,CAAC,EAAE,CAAC,QAAQ,EAAE,CAAC,CAAA;SAC9C;IACL,CAAC;IAED;;;OAGG;IACI,cAAc;QACjB,OAAO,cAAc,CAAC,IAAI,CAAC,CAAA;IAC/B,CAAC;IAED;;OAEG;IACI,aAAa;QAChB,UAAU,EAAE,CAAA;QACZ,gBAAgB,CAAC,IAAI,CAAC,CAAA;QACtB,QAAQ,EAAE,CAAA;IACd,CAAC;IAED,QAAQ;QACJ,OAAO,IAAI,CAAC,KAAK,CAAA;IACrB,CAAC;CACJ;AAED,MAAM,CAAC,MAAM,MAAM,GAAG,yBAAyB,CAAC,MAAM,EAAE,IAAI,CAAC,CAAA;AAE7D,MAAM,UAAU,UAAU,CACtB,IAAY,EACZ,0BAAsC,IAAI,EAC1C,4BAAwC,IAAI;IAE5C,MAAM,IAAI,GAAG,IAAI,IAAI,CAAC,IAAI,CAAC,CAAA;IAC3B,2DAA2D;IAC3D,IAAI,uBAAuB,KAAK,IAAI,EAAE;QAClC,gBAAgB,CAAC,IAAI,EAAE,uBAAuB,CAAC,CAAA;KAClD;IAED,IAAI,yBAAyB,KAAK,IAAI,EAAE;QACpC,kBAAkB,CAAC,IAAI,EAAE,yBAAyB,CAAC,CAAA;KACtD;IACD,OAAO,IAAI,CAAA;AACf,CAAC\"}","dts":{"name":"/Users/sergeigolishnikov/development/web/mobx/packages/mobx/core/atom.d.ts","writeByteOrderMark":false,"text":"import { IDerivationState_, IObservable, IDerivation, Lambda } from \"../internal\";\r\nexport declare const $mobx: unique symbol;\r\nexport interface IAtom extends IObservable {\r\n    reportObserved(): any;\r\n    reportChanged(): any;\r\n}\r\nexport declare class Atom implements IAtom {\r\n    name_: string;\r\n    isPendingUnobservation_: boolean;\r\n    isBeingObserved_: boolean;\r\n    observers_: Set<IDerivation>;\r\n    diffValue_: number;\r\n    lastAccessedBy_: number;\r\n    lowestObserverState_: IDerivationState_;\r\n    /**\r\n     * Create a new atom. For debugging purposes it is recommended to give it a name.\r\n     * The onBecomeObserved and onBecomeUnobserved callbacks can be used for resource management.\r\n     */\r\n    constructor(name_?: string);\r\n    onBOL: Set<Lambda> | undefined;\r\n    onBUOL: Set<Lambda> | undefined;\r\n    onBO(): void;\r\n    onBUO(): void;\r\n    /**\r\n     * Invoke this method to notify mobx that your atom has been used somehow.\r\n     * Returns true if there is currently a reactive context.\r\n     */\r\n    reportObserved(): boolean;\r\n    /**\r\n     * Invoke this method _after_ this method has changed to signal mobx that all its observers should invalidate.\r\n     */\r\n    reportChanged(): void;\r\n    toString(): string;\r\n}\r\nexport declare const isAtom: (x: any) => x is Atom;\r\nexport declare function createAtom(name: string, onBecomeObservedHandler?: () => void, onBecomeUnobservedHandler?: () => void): IAtom;\r\n"}}
