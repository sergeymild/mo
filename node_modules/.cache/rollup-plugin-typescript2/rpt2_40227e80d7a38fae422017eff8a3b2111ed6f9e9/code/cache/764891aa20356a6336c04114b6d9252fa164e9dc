{"code":"import { die, getGlobal } from \"../internal\";\r\n/**\r\n * These values will persist if global state is reset\r\n */\r\nconst persistentKeys = [\r\n    \"mobxGuid\",\r\n    \"spyListeners\",\r\n    \"enforceActions\",\r\n    \"computedRequiresReaction\",\r\n    \"reactionRequiresObservable\",\r\n    \"observableRequiresReaction\",\r\n    \"allowStateReads\",\r\n    \"disableErrorBoundaries\",\r\n    \"runId\",\r\n    \"UNCHANGED\",\r\n    \"useProxies\"\r\n];\r\nexport class MobXGlobals {\r\n    /**\r\n     * MobXGlobals version.\r\n     * MobX compatiblity with other versions loaded in memory as long as this version matches.\r\n     * It indicates that the global state still stores similar information\r\n     *\r\n     * N.B: this version is unrelated to the package version of MobX, and is only the version of the\r\n     * internal state storage of MobX, and can be the same across many different package versions\r\n     */\r\n    version = 6;\r\n    /**\r\n     * globally unique token to signal unchanged\r\n     */\r\n    UNCHANGED = {};\r\n    /**\r\n     * Currently running derivation\r\n     */\r\n    trackingDerivation = null;\r\n    /**\r\n     * Currently running reaction. This determines if we currently have a reactive context.\r\n     * (Tracking derivation is also set for temporal tracking of computed values inside actions,\r\n     * but trackingReaction can only be set by a form of Reaction)\r\n     */\r\n    trackingContext = null;\r\n    /**\r\n     * Each time a derivation is tracked, it is assigned a unique run-id\r\n     */\r\n    runId = 0;\r\n    /**\r\n     * 'guid' for general purpose. Will be persisted amongst resets.\r\n     */\r\n    mobxGuid = 0;\r\n    /**\r\n     * Are we in a batch block? (and how many of them)\r\n     */\r\n    inBatch = 0;\r\n    /**\r\n     * Observables that don't have observers anymore, and are about to be\r\n     * suspended, unless somebody else accesses it in the same batch\r\n     *\r\n     * @type {IObservable[]}\r\n     */\r\n    pendingUnobservations = [];\r\n    /**\r\n     * List of scheduled, not yet executed, reactions.\r\n     */\r\n    pendingReactions = [];\r\n    /**\r\n     * Are we currently processing reactions?\r\n     */\r\n    isRunningReactions = false;\r\n    /**\r\n     * Is it allowed to change observables at this point?\r\n     * In general, MobX doesn't allow that when running computations and React.render.\r\n     * To ensure that those functions stay pure.\r\n     */\r\n    allowStateChanges = false;\r\n    /**\r\n     * Is it allowed to read observables at this point?\r\n     * Used to hold the state needed for `observableRequiresReaction`\r\n     */\r\n    allowStateReads = true;\r\n    /**\r\n     * If strict mode is enabled, state changes are by default not allowed\r\n     */\r\n    enforceActions = true;\r\n    /**\r\n     * Spy callbacks\r\n     */\r\n    spyListeners = [];\r\n    /**\r\n     * Globally attached error handlers that react specifically to errors in reactions\r\n     */\r\n    globalReactionErrorHandlers = [];\r\n    /**\r\n     * Warn if computed values are accessed outside a reactive context\r\n     */\r\n    computedRequiresReaction = false;\r\n    /**\r\n     * (Experimental)\r\n     * Warn if you try to create to derivation / reactive context without accessing any observable.\r\n     */\r\n    reactionRequiresObservable = false;\r\n    /**\r\n     * (Experimental)\r\n     * Warn if observables are accessed outside a reactive context\r\n     */\r\n    observableRequiresReaction = false;\r\n    /*\r\n     * Don't catch and rethrow exceptions. This is useful for inspecting the state of\r\n     * the stack when an exception occurs while debugging.\r\n     */\r\n    disableErrorBoundaries = false;\r\n    /*\r\n     * If true, we are already handling an exception in an action. Any errors in reactions should be suppressed, as\r\n     * they are not the cause, see: https://github.com/mobxjs/mobx/issues/1836\r\n     */\r\n    suppressReactionErrors = false;\r\n    useProxies = true;\r\n    /*\r\n     * print warnings about code that would fail if proxies weren't available\r\n     */\r\n    verifyProxies = false;\r\n    /**\r\n     * False forces all object's descriptors to\r\n     * writable: true\r\n     * configurable: true\r\n     */\r\n    safeDescriptors = true;\r\n}\r\nlet canMergeGlobalState = true;\r\nlet isolateCalled = false;\r\nexport let globalState = (function () {\r\n    let global = getGlobal();\r\n    if (global.__mobxInstanceCount > 0 && !global.__mobxGlobals)\r\n        canMergeGlobalState = false;\r\n    if (global.__mobxGlobals && global.__mobxGlobals.version !== new MobXGlobals().version)\r\n        canMergeGlobalState = false;\r\n    if (!canMergeGlobalState) {\r\n        setTimeout(() => {\r\n            if (!isolateCalled) {\r\n                die(35);\r\n            }\r\n        }, 1);\r\n        return new MobXGlobals();\r\n    }\r\n    else if (global.__mobxGlobals) {\r\n        global.__mobxInstanceCount += 1;\r\n        if (!global.__mobxGlobals.UNCHANGED)\r\n            global.__mobxGlobals.UNCHANGED = {}; // make merge backward compatible\r\n        return global.__mobxGlobals;\r\n    }\r\n    else {\r\n        global.__mobxInstanceCount = 1;\r\n        return (global.__mobxGlobals = new MobXGlobals());\r\n    }\r\n})();\r\nexport function isolateGlobalState() {\r\n    if (globalState.pendingReactions.length ||\r\n        globalState.inBatch ||\r\n        globalState.isRunningReactions)\r\n        die(36);\r\n    isolateCalled = true;\r\n    if (canMergeGlobalState) {\r\n        let global = getGlobal();\r\n        if (--global.__mobxInstanceCount === 0)\r\n            global.__mobxGlobals = undefined;\r\n        globalState = new MobXGlobals();\r\n    }\r\n}\r\nexport function getGlobalState() {\r\n    return globalState;\r\n}\r\n/**\r\n * For testing purposes only; this will break the internal state of existing observables,\r\n * but can be used to get back at a stable state after throwing errors\r\n */\r\nexport function resetGlobalState() {\r\n    const defaultGlobals = new MobXGlobals();\r\n    for (let key in defaultGlobals)\r\n        if (persistentKeys.indexOf(key) === -1)\r\n            globalState[key] = defaultGlobals[key];\r\n    globalState.allowStateChanges = !globalState.enforceActions;\r\n}\r\n//# sourceMappingURL=globalstate.js.map","references":["/Users/sergeigolishnikov/development/web/mobx/packages/mobx/src/internal.ts","/Users/sergeigolishnikov/development/web/mobx/packages/mobx/src/core/computedvalue.ts"],"map":"{\"version\":3,\"file\":\"globalstate.js\",\"sourceRoot\":\"\",\"sources\":[\"../../../../../src/core/globalstate.ts\"],\"names\":[],\"mappings\":\"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\"}","dts":{"name":"/Users/sergeigolishnikov/development/web/mobx/packages/mobx/core/globalstate.d.ts","writeByteOrderMark":false,"text":"import { IDerivation, IObservable, Reaction } from \"../internal\";\r\nimport { ComputedValue } from \"./computedvalue\";\r\nexport declare type IUNCHANGED = {};\r\nexport declare class MobXGlobals {\r\n    /**\r\n     * MobXGlobals version.\r\n     * MobX compatiblity with other versions loaded in memory as long as this version matches.\r\n     * It indicates that the global state still stores similar information\r\n     *\r\n     * N.B: this version is unrelated to the package version of MobX, and is only the version of the\r\n     * internal state storage of MobX, and can be the same across many different package versions\r\n     */\r\n    version: number;\r\n    /**\r\n     * globally unique token to signal unchanged\r\n     */\r\n    UNCHANGED: IUNCHANGED;\r\n    /**\r\n     * Currently running derivation\r\n     */\r\n    trackingDerivation: IDerivation | null;\r\n    /**\r\n     * Currently running reaction. This determines if we currently have a reactive context.\r\n     * (Tracking derivation is also set for temporal tracking of computed values inside actions,\r\n     * but trackingReaction can only be set by a form of Reaction)\r\n     */\r\n    trackingContext: Reaction | ComputedValue<any> | null;\r\n    /**\r\n     * Each time a derivation is tracked, it is assigned a unique run-id\r\n     */\r\n    runId: number;\r\n    /**\r\n     * 'guid' for general purpose. Will be persisted amongst resets.\r\n     */\r\n    mobxGuid: number;\r\n    /**\r\n     * Are we in a batch block? (and how many of them)\r\n     */\r\n    inBatch: number;\r\n    /**\r\n     * Observables that don't have observers anymore, and are about to be\r\n     * suspended, unless somebody else accesses it in the same batch\r\n     *\r\n     * @type {IObservable[]}\r\n     */\r\n    pendingUnobservations: IObservable[];\r\n    /**\r\n     * List of scheduled, not yet executed, reactions.\r\n     */\r\n    pendingReactions: Reaction[];\r\n    /**\r\n     * Are we currently processing reactions?\r\n     */\r\n    isRunningReactions: boolean;\r\n    /**\r\n     * Is it allowed to change observables at this point?\r\n     * In general, MobX doesn't allow that when running computations and React.render.\r\n     * To ensure that those functions stay pure.\r\n     */\r\n    allowStateChanges: boolean;\r\n    /**\r\n     * Is it allowed to read observables at this point?\r\n     * Used to hold the state needed for `observableRequiresReaction`\r\n     */\r\n    allowStateReads: boolean;\r\n    /**\r\n     * If strict mode is enabled, state changes are by default not allowed\r\n     */\r\n    enforceActions: boolean | \"always\";\r\n    /**\r\n     * Spy callbacks\r\n     */\r\n    spyListeners: {\r\n        (change: any): void;\r\n    }[];\r\n    /**\r\n     * Globally attached error handlers that react specifically to errors in reactions\r\n     */\r\n    globalReactionErrorHandlers: ((error: any, derivation: IDerivation) => void)[];\r\n    /**\r\n     * Warn if computed values are accessed outside a reactive context\r\n     */\r\n    computedRequiresReaction: boolean;\r\n    /**\r\n     * (Experimental)\r\n     * Warn if you try to create to derivation / reactive context without accessing any observable.\r\n     */\r\n    reactionRequiresObservable: boolean;\r\n    /**\r\n     * (Experimental)\r\n     * Warn if observables are accessed outside a reactive context\r\n     */\r\n    observableRequiresReaction: boolean;\r\n    disableErrorBoundaries: boolean;\r\n    suppressReactionErrors: boolean;\r\n    useProxies: boolean;\r\n    verifyProxies: boolean;\r\n    /**\r\n     * False forces all object's descriptors to\r\n     * writable: true\r\n     * configurable: true\r\n     */\r\n    safeDescriptors: boolean;\r\n}\r\nexport declare let globalState: MobXGlobals;\r\nexport declare function isolateGlobalState(): void;\r\nexport declare function getGlobalState(): any;\r\n/**\r\n * For testing purposes only; this will break the internal state of existing observables,\r\n * but can be used to get back at a stable state after throwing errors\r\n */\r\nexport declare function resetGlobalState(): void;\r\n"}}
