{"code":"import { ComputedValue, storeAnnotation, createDecoratorAnnotation, isStringish, isPlainObject, isFunction, die, createComputedAnnotation, comparer } from \"../internal\";\r\nexport const COMPUTED = \"computed\";\r\nexport const COMPUTED_STRUCT = \"computed.struct\";\r\nconst computedAnnotation = createComputedAnnotation(COMPUTED);\r\nconst computedStructAnnotation = createComputedAnnotation(COMPUTED_STRUCT, {\r\n    equals: comparer.structural\r\n});\r\n/**\r\n * Decorator for class properties: @computed get value() { return expr; }.\r\n * For legacy purposes also invokable as ES5 observable created: `computed(() => expr)`;\r\n */\r\nexport const computed = function computed(arg1, arg2) {\r\n    if (isStringish(arg2)) {\r\n        // @computed\r\n        return storeAnnotation(arg1, arg2, computedAnnotation);\r\n    }\r\n    if (isPlainObject(arg1)) {\r\n        // @computed({ options })\r\n        return createDecoratorAnnotation(createComputedAnnotation(COMPUTED, arg1));\r\n    }\r\n    // computed(expr, options?)\r\n    if (__DEV__) {\r\n        if (!isFunction(arg1))\r\n            die(\"First argument to `computed` should be an expression.\");\r\n        if (isFunction(arg2))\r\n            die(\"A setter as second argument is no longer supported, use `{ set: fn }` option instead\");\r\n    }\r\n    const opts = isPlainObject(arg2) ? arg2 : {};\r\n    opts.get = arg1;\r\n    opts.name ||= arg1.name || \"\"; /* for generated name */\r\n    return new ComputedValue(opts);\r\n};\r\nObject.assign(computed, computedAnnotation);\r\ncomputed.struct = createDecoratorAnnotation(computedStructAnnotation);\r\n//# sourceMappingURL=computed.js.map","references":["/Users/sergeigolishnikov/development/web/mobx/packages/mobx/src/internal.ts"],"map":"{\"version\":3,\"file\":\"computed.js\",\"sourceRoot\":\"\",\"sources\":[\"../../../../../src/api/computed.ts\"],\"names\":[],\"mappings\":\"AAAA,OAAO,EACH,aAAa,EAGb,eAAe,EACf,yBAAyB,EACzB,WAAW,EACX,aAAa,EACb,UAAU,EACV,GAAG,EAEH,wBAAwB,EACxB,QAAQ,EACX,MAAM,aAAa,CAAA;AAEpB,MAAM,CAAC,MAAM,QAAQ,GAAG,UAAU,CAAA;AAClC,MAAM,CAAC,MAAM,eAAe,GAAG,iBAAiB,CAAA;AAWhD,MAAM,kBAAkB,GAAG,wBAAwB,CAAC,QAAQ,CAAC,CAAA;AAC7D,MAAM,wBAAwB,GAAG,wBAAwB,CAAC,eAAe,EAAE;IACvE,MAAM,EAAE,QAAQ,CAAC,UAAU;CAC9B,CAAC,CAAA;AAEF;;;GAGG;AACH,MAAM,CAAC,MAAM,QAAQ,GAAqB,SAAS,QAAQ,CAAC,IAAI,EAAE,IAAI;IAClE,IAAI,WAAW,CAAC,IAAI,CAAC,EAAE;QACnB,YAAY;QACZ,OAAO,eAAe,CAAC,IAAI,EAAE,IAAI,EAAE,kBAAkB,CAAC,CAAA;KACzD;IACD,IAAI,aAAa,CAAC,IAAI,CAAC,EAAE;QACrB,yBAAyB;QACzB,OAAO,yBAAyB,CAAC,wBAAwB,CAAC,QAAQ,EAAE,IAAI,CAAC,CAAC,CAAA;KAC7E;IAED,2BAA2B;IAC3B,IAAI,OAAO,EAAE;QACT,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC;YAAE,GAAG,CAAC,uDAAuD,CAAC,CAAA;QACnF,IAAI,UAAU,CAAC,IAAI,CAAC;YAChB,GAAG,CACC,sFAAsF,CACzF,CAAA;KACR;IACD,MAAM,IAAI,GAA+B,aAAa,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,CAAA;IACxE,IAAI,CAAC,GAAG,GAAG,IAAI,CAAA;IACf,IAAI,CAAC,IAAI,KAAK,IAAI,CAAC,IAAI,IAAI,EAAE,CAAA,CAAC,wBAAwB;IAEtD,OAAO,IAAI,aAAa,CAAC,IAAI,CAAC,CAAA;AAClC,CAAQ,CAAA;AAER,MAAM,CAAC,MAAM,CAAC,QAAQ,EAAE,kBAAkB,CAAC,CAAA;AAE3C,QAAQ,CAAC,MAAM,GAAG,yBAAyB,CAAC,wBAAwB,CAAC,CAAA\"}","dts":{"name":"/Users/sergeigolishnikov/development/web/mobx/packages/mobx/api/computed.d.ts","writeByteOrderMark":false,"text":"import { IComputedValueOptions, Annotation, IComputedValue } from \"../internal\";\r\nexport declare const COMPUTED = \"computed\";\r\nexport declare const COMPUTED_STRUCT = \"computed.struct\";\r\nexport interface IComputedFactory extends Annotation, PropertyDecorator {\r\n    <T>(options: IComputedValueOptions<T>): Annotation & PropertyDecorator;\r\n    <T>(func: () => T, options?: IComputedValueOptions<T>): IComputedValue<T>;\r\n    struct: Annotation & PropertyDecorator;\r\n}\r\n/**\r\n * Decorator for class properties: @computed get value() { return expr; }.\r\n * For legacy purposes also invokable as ES5 observable created: `computed(() => expr)`;\r\n */\r\nexport declare const computed: IComputedFactory;\r\n"}}
