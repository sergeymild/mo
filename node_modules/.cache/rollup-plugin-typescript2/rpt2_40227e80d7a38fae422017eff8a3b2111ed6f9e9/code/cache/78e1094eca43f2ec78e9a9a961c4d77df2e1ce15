{"code":"import { getAdministration, isFunction } from \"../internal\";\r\nexport function intercept(thing, propOrHandler, handler) {\r\n    if (isFunction(handler))\r\n        return interceptProperty(thing, propOrHandler, handler);\r\n    else\r\n        return interceptInterceptable(thing, propOrHandler);\r\n}\r\nfunction interceptInterceptable(thing, handler) {\r\n    return getAdministration(thing).intercept_(handler);\r\n}\r\nfunction interceptProperty(thing, property, handler) {\r\n    return getAdministration(thing, property).intercept_(handler);\r\n}\r\n//# sourceMappingURL=intercept.js.map","references":["/Users/sergeigolishnikov/development/web/mobx/packages/mobx/src/internal.ts"],"map":"{\"version\":3,\"file\":\"intercept.js\",\"sourceRoot\":\"\",\"sources\":[\"../../../../../src/api/intercept.ts\"],\"names\":[],\"mappings\":\"AAAA,OAAO,EAWH,iBAAiB,EAGjB,UAAU,EACb,MAAM,aAAa,CAAA;AA6BpB,MAAM,UAAU,SAAS,CAAC,KAAK,EAAE,aAAc,EAAE,OAAQ;IACrD,IAAI,UAAU,CAAC,OAAO,CAAC;QAAE,OAAO,iBAAiB,CAAC,KAAK,EAAE,aAAa,EAAE,OAAO,CAAC,CAAA;;QAC3E,OAAO,sBAAsB,CAAC,KAAK,EAAE,aAAa,CAAC,CAAA;AAC5D,CAAC;AAED,SAAS,sBAAsB,CAAC,KAAK,EAAE,OAAO;IAC1C,OAAO,iBAAiB,CAAC,KAAK,CAAC,CAAC,UAAU,CAAC,OAAO,CAAC,CAAA;AACvD,CAAC;AAED,SAAS,iBAAiB,CAAC,KAAK,EAAE,QAAQ,EAAE,OAAO;IAC/C,OAAO,iBAAiB,CAAC,KAAK,EAAE,QAAQ,CAAC,CAAC,UAAU,CAAC,OAAO,CAAC,CAAA;AACjE,CAAC\"}","dts":{"name":"/Users/sergeigolishnikov/development/web/mobx/packages/mobx/api/intercept.d.ts","writeByteOrderMark":false,"text":"import { IArrayWillChange, IArrayWillSplice, IInterceptor, IMapWillChange, IObjectWillChange, IObservableArray, IObservableValue, IValueWillChange, Lambda, ObservableMap, ObservableSet, ISetWillChange } from \"../internal\";\r\nexport declare function intercept<T>(value: IObservableValue<T>, handler: IInterceptor<IValueWillChange<T>>): Lambda;\r\nexport declare function intercept<T>(observableArray: IObservableArray<T>, handler: IInterceptor<IArrayWillChange<T> | IArrayWillSplice<T>>): Lambda;\r\nexport declare function intercept<K, V>(observableMap: ObservableMap<K, V>, handler: IInterceptor<IMapWillChange<K, V>>): Lambda;\r\nexport declare function intercept<V>(observableMap: ObservableSet<V>, handler: IInterceptor<ISetWillChange<V>>): Lambda;\r\nexport declare function intercept<K, V>(observableMap: ObservableMap<K, V>, property: K, handler: IInterceptor<IValueWillChange<V>>): Lambda;\r\nexport declare function intercept(object: object, handler: IInterceptor<IObjectWillChange>): Lambda;\r\nexport declare function intercept<T extends object, K extends keyof T>(object: T, property: K, handler: IInterceptor<IValueWillChange<any>>): Lambda;\r\n"}}
