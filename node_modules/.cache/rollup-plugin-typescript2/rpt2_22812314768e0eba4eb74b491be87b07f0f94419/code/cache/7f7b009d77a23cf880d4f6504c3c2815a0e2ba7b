{"code":"import { $mobx, ObservableValue, checkIfStateModificationsAreAllowed, createAtom, createInstanceofPredicate, deepEnhancer, getNextId, getPlainObjectKeys, hasInterceptors, hasListeners, interceptChange, isES6Map, isPlainObject, isSpyEnabled, makeIterable, notifyListeners, referenceEnhancer, registerInterceptor, registerListener, spyReportEnd, spyReportStart, stringifyKey, transaction, untracked, onBecomeUnobserved, globalState, die, isFunction, UPDATE } from \"../internal\";\r\nconst ObservableMapMarker = {};\r\nexport const ADD = \"add\";\r\nexport const DELETE = \"delete\";\r\n// just extend Map? See also https://gist.github.com/nestharus/13b4d74f2ef4a2f4357dbd3fc23c1e54\r\n// But: https://github.com/mobxjs/mobx/issues/1556\r\nexport class ObservableMap {\r\n    enhancer_;\r\n    name_;\r\n    [$mobx] = ObservableMapMarker;\r\n    data_;\r\n    hasMap_; // hasMap, not hashMap >-).\r\n    keysAtom_;\r\n    interceptors_;\r\n    changeListeners_;\r\n    dehancer;\r\n    constructor(initialData, enhancer_ = deepEnhancer, name_ = __DEV__ ? \"ObservableMap@\" + getNextId() : \"ObservableMap\") {\r\n        this.enhancer_ = enhancer_;\r\n        this.name_ = name_;\r\n        if (!isFunction(Map)) {\r\n            die(18);\r\n        }\r\n        this.keysAtom_ = createAtom(__DEV__ ? `${this.name_}.keys()` : \"ObservableMap.keys()\");\r\n        this.data_ = new Map();\r\n        this.hasMap_ = new Map();\r\n        this.merge(initialData);\r\n    }\r\n    has_(key) {\r\n        return this.data_.has(key);\r\n    }\r\n    has(key) {\r\n        if (!globalState.trackingDerivation)\r\n            return this.has_(key);\r\n        let entry = this.hasMap_.get(key);\r\n        if (!entry) {\r\n            const newEntry = (entry = new ObservableValue(this.has_(key), referenceEnhancer, __DEV__ ? `${this.name_}.${stringifyKey(key)}?` : \"ObservableMap.key?\", false));\r\n            this.hasMap_.set(key, newEntry);\r\n            onBecomeUnobserved(newEntry, () => this.hasMap_.delete(key));\r\n        }\r\n        return entry.get();\r\n    }\r\n    set(key, value) {\r\n        const hasKey = this.has_(key);\r\n        if (hasInterceptors(this)) {\r\n            const change = interceptChange(this, {\r\n                type: hasKey ? UPDATE : ADD,\r\n                object: this,\r\n                newValue: value,\r\n                name: key\r\n            });\r\n            if (!change)\r\n                return this;\r\n            value = change.newValue;\r\n        }\r\n        if (hasKey) {\r\n            this.updateValue_(key, value);\r\n        }\r\n        else {\r\n            this.addValue_(key, value);\r\n        }\r\n        return this;\r\n    }\r\n    delete(key) {\r\n        checkIfStateModificationsAreAllowed(this.keysAtom_);\r\n        if (hasInterceptors(this)) {\r\n            const change = interceptChange(this, {\r\n                type: DELETE,\r\n                object: this,\r\n                name: key\r\n            });\r\n            if (!change)\r\n                return false;\r\n        }\r\n        if (this.has_(key)) {\r\n            const notifySpy = isSpyEnabled();\r\n            const notify = hasListeners(this);\r\n            const change = notify || notifySpy\r\n                ? {\r\n                    observableKind: \"map\",\r\n                    debugObjectName: this.name_,\r\n                    type: DELETE,\r\n                    object: this,\r\n                    oldValue: this.data_.get(key).value_,\r\n                    name: key\r\n                }\r\n                : null;\r\n            if (__DEV__ && notifySpy)\r\n                spyReportStart(change);\r\n            transaction(() => {\r\n                this.keysAtom_.reportChanged();\r\n                this.updateHasMapEntry_(key, false);\r\n                const observable = this.data_.get(key);\r\n                observable.setNewValue_(undefined);\r\n                this.data_.delete(key);\r\n            });\r\n            if (notify)\r\n                notifyListeners(this, change);\r\n            if (__DEV__ && notifySpy)\r\n                spyReportEnd();\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    updateHasMapEntry_(key, value) {\r\n        let entry = this.hasMap_.get(key);\r\n        if (entry) {\r\n            entry.setNewValue_(value);\r\n        }\r\n    }\r\n    updateValue_(key, newValue) {\r\n        const observable = this.data_.get(key);\r\n        newValue = observable.prepareNewValue_(newValue);\r\n        if (newValue !== globalState.UNCHANGED) {\r\n            const notifySpy = isSpyEnabled();\r\n            const notify = hasListeners(this);\r\n            const change = notify || notifySpy\r\n                ? {\r\n                    observableKind: \"map\",\r\n                    debugObjectName: this.name_,\r\n                    type: UPDATE,\r\n                    object: this,\r\n                    oldValue: observable.value_,\r\n                    name: key,\r\n                    newValue\r\n                }\r\n                : null;\r\n            if (__DEV__ && notifySpy)\r\n                spyReportStart(change);\r\n            observable.setNewValue_(newValue);\r\n            if (notify)\r\n                notifyListeners(this, change);\r\n            if (__DEV__ && notifySpy)\r\n                spyReportEnd();\r\n        }\r\n    }\r\n    addValue_(key, newValue) {\r\n        checkIfStateModificationsAreAllowed(this.keysAtom_);\r\n        transaction(() => {\r\n            const observable = new ObservableValue(newValue, this.enhancer_, __DEV__ ? `${this.name_}.${stringifyKey(key)}` : \"ObservableMap.key\", false);\r\n            this.data_.set(key, observable);\r\n            newValue = observable.value_; // value might have been changed\r\n            this.updateHasMapEntry_(key, true);\r\n            this.keysAtom_.reportChanged();\r\n        });\r\n        const notifySpy = isSpyEnabled();\r\n        const notify = hasListeners(this);\r\n        const change = notify || notifySpy\r\n            ? {\r\n                observableKind: \"map\",\r\n                debugObjectName: this.name_,\r\n                type: ADD,\r\n                object: this,\r\n                name: key,\r\n                newValue\r\n            }\r\n            : null;\r\n        if (__DEV__ && notifySpy)\r\n            spyReportStart(change);\r\n        if (notify)\r\n            notifyListeners(this, change);\r\n        if (__DEV__ && notifySpy)\r\n            spyReportEnd();\r\n    }\r\n    get(key) {\r\n        if (this.has(key))\r\n            return this.dehanceValue_(this.data_.get(key).get());\r\n        return this.dehanceValue_(undefined);\r\n    }\r\n    dehanceValue_(value) {\r\n        if (this.dehancer !== undefined) {\r\n            return this.dehancer(value);\r\n        }\r\n        return value;\r\n    }\r\n    keys() {\r\n        this.keysAtom_.reportObserved();\r\n        return this.data_.keys();\r\n    }\r\n    values() {\r\n        const self = this;\r\n        const keys = this.keys();\r\n        return makeIterable({\r\n            next() {\r\n                const { done, value } = keys.next();\r\n                return {\r\n                    done,\r\n                    value: done ? undefined : self.get(value)\r\n                };\r\n            }\r\n        });\r\n    }\r\n    entries() {\r\n        const self = this;\r\n        const keys = this.keys();\r\n        return makeIterable({\r\n            next() {\r\n                const { done, value } = keys.next();\r\n                return {\r\n                    done,\r\n                    value: done ? undefined : [value, self.get(value)]\r\n                };\r\n            }\r\n        });\r\n    }\r\n    [Symbol.iterator]() {\r\n        return this.entries();\r\n    }\r\n    forEach(callback, thisArg) {\r\n        for (const [key, value] of this)\r\n            callback.call(thisArg, value, key, this);\r\n    }\r\n    /** Merge another object into this object, returns this. */\r\n    merge(other) {\r\n        if (isObservableMap(other)) {\r\n            other = new Map(other);\r\n        }\r\n        transaction(() => {\r\n            if (isPlainObject(other))\r\n                getPlainObjectKeys(other).forEach((key) => this.set(key, other[key]));\r\n            else if (Array.isArray(other))\r\n                other.forEach(([key, value]) => this.set(key, value));\r\n            else if (isES6Map(other)) {\r\n                if (other.constructor !== Map)\r\n                    die(19, other);\r\n                other.forEach((value, key) => this.set(key, value));\r\n            }\r\n            else if (other !== null && other !== undefined)\r\n                die(20, other);\r\n        });\r\n        return this;\r\n    }\r\n    clear() {\r\n        transaction(() => {\r\n            untracked(() => {\r\n                for (const key of this.keys())\r\n                    this.delete(key);\r\n            });\r\n        });\r\n    }\r\n    replace(values) {\r\n        // Implementation requirements:\r\n        // - respect ordering of replacement map\r\n        // - allow interceptors to run and potentially prevent individual operations\r\n        // - don't recreate observables that already exist in original map (so we don't destroy existing subscriptions)\r\n        // - don't _keysAtom.reportChanged if the keys of resulting map are indentical (order matters!)\r\n        // - note that result map may differ from replacement map due to the interceptors\r\n        transaction(() => {\r\n            // Convert to map so we can do quick key lookups\r\n            const replacementMap = convertToMap(values);\r\n            const orderedData = new Map();\r\n            // Used for optimization\r\n            let keysReportChangedCalled = false;\r\n            // Delete keys that don't exist in replacement map\r\n            // if the key deletion is prevented by interceptor\r\n            // add entry at the beginning of the result map\r\n            for (const key of this.data_.keys()) {\r\n                // Concurrently iterating/deleting keys\r\n                // iterator should handle this correctly\r\n                if (!replacementMap.has(key)) {\r\n                    const deleted = this.delete(key);\r\n                    // Was the key removed?\r\n                    if (deleted) {\r\n                        // _keysAtom.reportChanged() was already called\r\n                        keysReportChangedCalled = true;\r\n                    }\r\n                    else {\r\n                        // Delete prevented by interceptor\r\n                        const value = this.data_.get(key);\r\n                        orderedData.set(key, value);\r\n                    }\r\n                }\r\n            }\r\n            // Merge entries\r\n            for (const [key, value] of replacementMap.entries()) {\r\n                // We will want to know whether a new key is added\r\n                const keyExisted = this.data_.has(key);\r\n                // Add or update value\r\n                this.set(key, value);\r\n                // The addition could have been prevent by interceptor\r\n                if (this.data_.has(key)) {\r\n                    // The update could have been prevented by interceptor\r\n                    // and also we want to preserve existing values\r\n                    // so use value from _data map (instead of replacement map)\r\n                    const value = this.data_.get(key);\r\n                    orderedData.set(key, value);\r\n                    // Was a new key added?\r\n                    if (!keyExisted) {\r\n                        // _keysAtom.reportChanged() was already called\r\n                        keysReportChangedCalled = true;\r\n                    }\r\n                }\r\n            }\r\n            // Check for possible key order change\r\n            if (!keysReportChangedCalled) {\r\n                if (this.data_.size !== orderedData.size) {\r\n                    // If size differs, keys are definitely modified\r\n                    this.keysAtom_.reportChanged();\r\n                }\r\n                else {\r\n                    const iter1 = this.data_.keys();\r\n                    const iter2 = orderedData.keys();\r\n                    let next1 = iter1.next();\r\n                    let next2 = iter2.next();\r\n                    while (!next1.done) {\r\n                        if (next1.value !== next2.value) {\r\n                            this.keysAtom_.reportChanged();\r\n                            break;\r\n                        }\r\n                        next1 = iter1.next();\r\n                        next2 = iter2.next();\r\n                    }\r\n                }\r\n            }\r\n            // Use correctly ordered map\r\n            this.data_ = orderedData;\r\n        });\r\n        return this;\r\n    }\r\n    get size() {\r\n        this.keysAtom_.reportObserved();\r\n        return this.data_.size;\r\n    }\r\n    toString() {\r\n        return \"[object ObservableMap]\";\r\n    }\r\n    toJSON() {\r\n        return Array.from(this);\r\n    }\r\n    get [Symbol.toStringTag]() {\r\n        return \"Map\";\r\n    }\r\n    /**\r\n     * Observes this object. Triggers for the events 'add', 'update' and 'delete'.\r\n     * See: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/observe\r\n     * for callback details\r\n     */\r\n    observe_(listener, fireImmediately) {\r\n        if (__DEV__ && fireImmediately === true)\r\n            die(\"`observe` doesn't support fireImmediately=true in combination with maps.\");\r\n        return registerListener(this, listener);\r\n    }\r\n    intercept_(handler) {\r\n        return registerInterceptor(this, handler);\r\n    }\r\n}\r\n// eslint-disable-next-line\r\nexport var isObservableMap = createInstanceofPredicate(\"ObservableMap\", ObservableMap);\r\nfunction convertToMap(dataStructure) {\r\n    if (isES6Map(dataStructure) || isObservableMap(dataStructure)) {\r\n        return dataStructure;\r\n    }\r\n    else if (Array.isArray(dataStructure)) {\r\n        return new Map(dataStructure);\r\n    }\r\n    else if (isPlainObject(dataStructure)) {\r\n        const map = new Map();\r\n        for (const key in dataStructure) {\r\n            map.set(key, dataStructure[key]);\r\n        }\r\n        return map;\r\n    }\r\n    else {\r\n        return die(21, dataStructure);\r\n    }\r\n}\r\n//# sourceMappingURL=observablemap.js.map","references":["/Users/sergeigolishnikov/development/web/mobx/packages/mobx/src/internal.ts"],"map":"{\"version\":3,\"file\":\"observablemap.js\",\"sourceRoot\":\"\",\"sources\":[\"../../../../../src/types/observablemap.ts\"],\"names\":[],\"mappings\":\"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\"}","dts":{"name":"/Users/sergeigolishnikov/development/web/mobx/packages/mobx/types/observablemap.d.ts","writeByteOrderMark":false,"text":"import { $mobx, IEnhancer, IInterceptable, IInterceptor, IListenable, Lambda, ObservableValue, IAtom } from \"../internal\";\r\nexport interface IKeyValueMap<V = any> {\r\n    [key: string]: V;\r\n}\r\nexport declare type IMapEntry<K = any, V = any> = [K, V];\r\nexport declare type IMapEntries<K = any, V = any> = IMapEntry<K, V>[];\r\nexport declare type IMapDidChange<K = any, V = any> = {\r\n    observableKind: \"map\";\r\n    debugObjectName: string;\r\n} & ({\r\n    object: ObservableMap<K, V>;\r\n    name: K;\r\n    type: \"update\";\r\n    newValue: V;\r\n    oldValue: V;\r\n} | {\r\n    object: ObservableMap<K, V>;\r\n    name: K;\r\n    type: \"add\";\r\n    newValue: V;\r\n} | {\r\n    object: ObservableMap<K, V>;\r\n    name: K;\r\n    type: \"delete\";\r\n    oldValue: V;\r\n});\r\nexport interface IMapWillChange<K = any, V = any> {\r\n    object: ObservableMap<K, V>;\r\n    type: \"update\" | \"add\" | \"delete\";\r\n    name: K;\r\n    newValue?: V;\r\n}\r\nexport declare const ADD = \"add\";\r\nexport declare const DELETE = \"delete\";\r\nexport declare type IObservableMapInitialValues<K = any, V = any> = IMapEntries<K, V> | IKeyValueMap<V> | Map<K, V>;\r\nexport declare class ObservableMap<K = any, V = any> implements Map<K, V>, IInterceptable<IMapWillChange<K, V>>, IListenable {\r\n    enhancer_: IEnhancer<V>;\r\n    name_: string;\r\n    [$mobx]: {};\r\n    data_: Map<K, ObservableValue<V>>;\r\n    hasMap_: Map<K, ObservableValue<boolean>>;\r\n    keysAtom_: IAtom;\r\n    interceptors_: any;\r\n    changeListeners_: any;\r\n    dehancer: any;\r\n    constructor(initialData?: IObservableMapInitialValues<K, V>, enhancer_?: IEnhancer<V>, name_?: string);\r\n    private has_;\r\n    has(key: K): boolean;\r\n    set(key: K, value: V): this;\r\n    delete(key: K): boolean;\r\n    private updateHasMapEntry_;\r\n    private updateValue_;\r\n    private addValue_;\r\n    get(key: K): V | undefined;\r\n    private dehanceValue_;\r\n    keys(): IterableIterator<K>;\r\n    values(): IterableIterator<V>;\r\n    entries(): IterableIterator<IMapEntry<K, V>>;\r\n    [Symbol.iterator](): IterableIterator<IMapEntry<K, V>>;\r\n    forEach(callback: (value: V, key: K, object: Map<K, V>) => void, thisArg?: any): void;\r\n    /** Merge another object into this object, returns this. */\r\n    merge(other: ObservableMap<K, V> | IKeyValueMap<V> | any): ObservableMap<K, V>;\r\n    clear(): void;\r\n    replace(values: ObservableMap<K, V> | IKeyValueMap<V> | any): ObservableMap<K, V>;\r\n    get size(): number;\r\n    toString(): string;\r\n    toJSON(): [K, V][];\r\n    get [Symbol.toStringTag](): string;\r\n    /**\r\n     * Observes this object. Triggers for the events 'add', 'update' and 'delete'.\r\n     * See: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/observe\r\n     * for callback details\r\n     */\r\n    observe_(listener: (changes: IMapDidChange<K, V>) => void, fireImmediately?: boolean): Lambda;\r\n    intercept_(handler: IInterceptor<IMapWillChange<K, V>>): Lambda;\r\n}\r\nexport declare var isObservableMap: (thing: any) => thing is ObservableMap<any, any>;\r\n"}}
