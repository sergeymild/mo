{"code":"import { addHiddenProp, hasProp, die, isOverride } from \"../internal\";\r\nexport const storedAnnotationsSymbol = Symbol(\"mobx-stored-annotations\");\r\n/**\r\n * Creates a function that acts as\r\n * - decorator\r\n * - annotation object\r\n */\r\nexport function createDecoratorAnnotation(annotation) {\r\n    function decorator(target, property) {\r\n        storeAnnotation(target, property, annotation);\r\n    }\r\n    return Object.assign(decorator, annotation);\r\n}\r\n/**\r\n * Stores annotation to prototype,\r\n * so it can be inspected later by `makeObservable` called from constructor\r\n */\r\nexport function storeAnnotation(prototype, key, annotation) {\r\n    if (!hasProp(prototype, storedAnnotationsSymbol)) {\r\n        addHiddenProp(prototype, storedAnnotationsSymbol, {\r\n            // Inherit annotations\r\n            ...prototype[storedAnnotationsSymbol]\r\n        });\r\n    }\r\n    // @override must override something\r\n    if (__DEV__ && isOverride(annotation) && !hasProp(prototype[storedAnnotationsSymbol], key)) {\r\n        const fieldName = `${prototype.constructor.name}.prototype.${key.toString()}`;\r\n        die(`'${fieldName}' is decorated with 'override', ` +\r\n            `but no such decorated member was found on prototype.`);\r\n    }\r\n    // Cannot re-decorate\r\n    assertNotDecorated(prototype, annotation, key);\r\n    // Ignore override\r\n    if (!isOverride(annotation)) {\r\n        prototype[storedAnnotationsSymbol][key] = annotation;\r\n    }\r\n}\r\nfunction assertNotDecorated(prototype, annotation, key) {\r\n    if (__DEV__ && !isOverride(annotation) && hasProp(prototype[storedAnnotationsSymbol], key)) {\r\n        const fieldName = `${prototype.constructor.name}.prototype.${key.toString()}`;\r\n        const currentAnnotationType = prototype[storedAnnotationsSymbol][key].annotationType_;\r\n        const requestedAnnotationType = annotation.annotationType_;\r\n        die(`Cannot apply '@${requestedAnnotationType}' to '${fieldName}':` +\r\n            `\\nThe field is already decorated with '@${currentAnnotationType}'.` +\r\n            `\\nRe-decorating fields is not allowed.` +\r\n            `\\nUse '@override' decorator for methods overriden by subclass.`);\r\n    }\r\n}\r\n/**\r\n * Collects annotations from prototypes and stores them on target (instance)\r\n */\r\nexport function collectStoredAnnotations(target) {\r\n    if (!hasProp(target, storedAnnotationsSymbol)) {\r\n        if (__DEV__ && !target[storedAnnotationsSymbol]) {\r\n            die(`No annotations were passed to makeObservable, but no decorated members have been found either`);\r\n        }\r\n        // We need a copy as we will remove annotation from the list once it's applied.\r\n        addHiddenProp(target, storedAnnotationsSymbol, { ...target[storedAnnotationsSymbol] });\r\n    }\r\n    return target[storedAnnotationsSymbol];\r\n}\r\n//# sourceMappingURL=decorators.js.map","references":["/Users/sergeigolishnikov/development/web/mobx/packages/mobx/src/internal.ts"],"map":"{\"version\":3,\"file\":\"decorators.js\",\"sourceRoot\":\"\",\"sources\":[\"../../../../../src/api/decorators.ts\"],\"names\":[],\"mappings\":\"AAAA,OAAO,EAAc,aAAa,EAAkB,OAAO,EAAE,GAAG,EAAE,UAAU,EAAE,MAAM,aAAa,CAAA;AAEjG,MAAM,CAAC,MAAM,uBAAuB,GAAG,MAAM,CAAC,yBAAyB,CAAC,CAAA;AAExE;;;;GAIG;AACH,MAAM,UAAU,yBAAyB,CAAC,UAAsB;IAC5D,SAAS,SAAS,CAAC,MAAM,EAAE,QAAQ;QAC/B,eAAe,CAAC,MAAM,EAAE,QAAQ,EAAE,UAAU,CAAC,CAAA;IACjD,CAAC;IACD,OAAO,MAAM,CAAC,MAAM,CAAC,SAAS,EAAE,UAAU,CAAC,CAAA;AAC/C,CAAC;AAED;;;GAGG;AACH,MAAM,UAAU,eAAe,CAAC,SAAc,EAAE,GAAgB,EAAE,UAAsB;IACpF,IAAI,CAAC,OAAO,CAAC,SAAS,EAAE,uBAAuB,CAAC,EAAE;QAC9C,aAAa,CAAC,SAAS,EAAE,uBAAuB,EAAE;YAC9C,sBAAsB;YACtB,GAAG,SAAS,CAAC,uBAAuB,CAAC;SACxC,CAAC,CAAA;KACL;IACD,oCAAoC;IACpC,IAAI,OAAO,IAAI,UAAU,CAAC,UAAU,CAAC,IAAI,CAAC,OAAO,CAAC,SAAS,CAAC,uBAAuB,CAAC,EAAE,GAAG,CAAC,EAAE;QACxF,MAAM,SAAS,GAAG,GAAG,SAAS,CAAC,WAAW,CAAC,IAAI,cAAc,GAAG,CAAC,QAAQ,EAAE,EAAE,CAAA;QAC7E,GAAG,CACC,IAAI,SAAS,kCAAkC;YAC3C,sDAAsD,CAC7D,CAAA;KACJ;IACD,qBAAqB;IACrB,kBAAkB,CAAC,SAAS,EAAE,UAAU,EAAE,GAAG,CAAC,CAAA;IAE9C,kBAAkB;IAClB,IAAI,CAAC,UAAU,CAAC,UAAU,CAAC,EAAE;QACzB,SAAS,CAAC,uBAAuB,CAAC,CAAC,GAAG,CAAC,GAAG,UAAU,CAAA;KACvD;AACL,CAAC;AAED,SAAS,kBAAkB,CAAC,SAAiB,EAAE,UAAsB,EAAE,GAAgB;IACnF,IAAI,OAAO,IAAI,CAAC,UAAU,CAAC,UAAU,CAAC,IAAI,OAAO,CAAC,SAAS,CAAC,uBAAuB,CAAC,EAAE,GAAG,CAAC,EAAE;QACxF,MAAM,SAAS,GAAG,GAAG,SAAS,CAAC,WAAW,CAAC,IAAI,cAAc,GAAG,CAAC,QAAQ,EAAE,EAAE,CAAA;QAC7E,MAAM,qBAAqB,GAAG,SAAS,CAAC,uBAAuB,CAAC,CAAC,GAAG,CAAC,CAAC,eAAe,CAAA;QACrF,MAAM,uBAAuB,GAAG,UAAU,CAAC,eAAe,CAAA;QAC1D,GAAG,CACC,kBAAkB,uBAAuB,SAAS,SAAS,IAAI;YAC3D,2CAA2C,qBAAqB,IAAI;YACpE,wCAAwC;YACxC,gEAAgE,CACvE,CAAA;KACJ;AACL,CAAC;AAED;;GAEG;AACH,MAAM,UAAU,wBAAwB,CAAC,MAAM;IAC3C,IAAI,CAAC,OAAO,CAAC,MAAM,EAAE,uBAAuB,CAAC,EAAE;QAC3C,IAAI,OAAO,IAAI,CAAC,MAAM,CAAC,uBAAuB,CAAC,EAAE;YAC7C,GAAG,CACC,+FAA+F,CAClG,CAAA;SACJ;QACD,+EAA+E;QAC/E,aAAa,CAAC,MAAM,EAAE,uBAAuB,EAAE,EAAE,GAAG,MAAM,CAAC,uBAAuB,CAAC,EAAE,CAAC,CAAA;KACzF;IACD,OAAO,MAAM,CAAC,uBAAuB,CAAC,CAAA;AAC1C,CAAC\"}","dts":{"name":"/Users/sergeigolishnikov/development/web/mobx/packages/mobx/api/decorators.d.ts","writeByteOrderMark":false,"text":"import { Annotation, AnnotationsMap } from \"../internal\";\r\nexport declare const storedAnnotationsSymbol: unique symbol;\r\n/**\r\n * Creates a function that acts as\r\n * - decorator\r\n * - annotation object\r\n */\r\nexport declare function createDecoratorAnnotation(annotation: Annotation): PropertyDecorator & Annotation;\r\n/**\r\n * Stores annotation to prototype,\r\n * so it can be inspected later by `makeObservable` called from constructor\r\n */\r\nexport declare function storeAnnotation(prototype: any, key: PropertyKey, annotation: Annotation): void;\r\n/**\r\n * Collects annotations from prototypes and stores them on target (instance)\r\n */\r\nexport declare function collectStoredAnnotations(target: any): AnnotationsMap<any, any>;\r\n"}}
